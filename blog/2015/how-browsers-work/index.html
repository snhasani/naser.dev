<!DOCTYPE html> <html lang=fa dir=rtl prefix="og: http://ogp.me/ns#"> <head>  <meta charset=utf-8> <title>مرورگرها چگونه کار می‌کنند؟</title> <meta name=viewport content="width=device-width, initial-scale=1.0">  <script>
		    if ( window.localStorage.theme === 'dark' )  document.documentElement.classList.add('dark')
		</script>  <style id=above-the-fold-css>html{box-sizing:border-box}*,*::before,*::after{box-sizing:inherit}body{background-color:#F9F9F9;color:#333;margin:0;overflow-x:hidden;transition:.25s}.dark body{background-color:#333;color:#ddd}a{color:#FF0037;text-decoration:none}.dark a{color:#FFC107}img{max-width:100%;height:auto;display:block;max-height:80vh;margin:0 auto}.nav__item>a{transition:-webkit-transform 0.15s;transition:transform 0.15s;position:relative}.nav__item>a::before{transition:inherit;position:absolute;top:100%;left:0;right:0;height:1px;background:currentcolor;-webkit-transform:scaleX(0);transform:scaleX(0)}.nav__item>a:active::before,.nav__item>a:hover::before{-webkit-transform:scaleX(1);transform:scaleX(1)}.nav__item>a{color:inherit}.nav__item>a:hover{color:#FF0037}.dark .nav__item>a:hover{color:#FFC107}.mb-half,.post-content li{margin-bottom:1rem}.mb-base,dd{margin-bottom:2rem}.mb-double{margin-bottom:4rem}.text-center{text-align:center}.ltr{direction:ltr !important}.clearfix::after{clear:both;content:'';display:table}.container{max-width:800px;margin-left:auto;margin-right:auto;padding-left:20px;padding-right:20px;width:100%}.post-content>p{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}h1,h2,h3,h4,h5,h6,p,blockquote,pre,dl,ol,ul,form,fieldset,legend,table,th,td,caption,hr{margin:0;padding:0}label,input,textarea,button,select,option{cursor:pointer}textarea:active,textarea:focus{cursor:text;outline:none}fieldset{border:0;margin:0;padding:0}textarea{resize:vertical}input[type="search"],input[type="input"]{box-sizing:border-box}input[name="username"],input[type="password"],input[type="url"]{direction:ltr !important}::-moz-selection{background:#b3d4fc;text-shadow:none}::selection{background:#b3d4fc;text-shadow:none}audio,canvas,iframe,img,svg,video{vertical-align:middle}h1,h2,h3,h4,h5,h6,hgroup,ul,ol,dl,blockquote,p,address,table,fieldset,figure,pre{margin-top:0;margin-bottom:2rem}hr{margin-bottom:1.8571428571rem}ul,ol,dd{margin-right:2rem}.avatar{border-radius:30% 5% 5%;max-height:168px;margin:0 auto 2rem}h1,.h1{font-size:1.8571428571rem;line-height:2.1538461538}h2,.h2{font-size:1.5714285714rem;line-height:2.5454545455}h3,.h3{font-size:1.2857142857rem;line-height:3.1111111111}h4,.h4{font-size:1rem;line-height:2}html{font:0.875rem/2 "IranSansLight","Arial","Tahoma",sans-serif}p{margin:0 0 2rem}.large-text{font-size:1.0714285714rem;line-height:1.8666666667}.block-text{display:block}p abbr[title],li abbr[title]{border-bottom:1px dotted;cursor:help}.site-header{margin-bottom:5rem}.logo{font-size:3.7142857143rem;line-height:1.0769230769;display:inline-block}.logo>svg{fill:#444;height:33px;max-width:180px;width:100%}.dark .logo>svg{fill:#ddd}.logo__atsign{fill:#CCC}.dark .logo__atsign{fill:#666}.logo__underline{fill:#FF0037;-webkit-animation:blink 1s infinite steps(1);animation:blink 1s infinite steps(1)}@-webkit-keyframes blink{50%{opacity:0}}@keyframes blink{50%{opacity:0}}.nav__item{font-size:1.0714285714rem;line-height:1.8666666667;color:#666;display:inline-block;margin:0 1em;white-space:nowrap}.dark .nav__item{color:#aaa}.list{padding:0;margin:0;list-style:none;clear:both}[data-page=default]>.page-wrapper{display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;min-height:100vh;padding:28px 0}.page-header{margin-bottom:7rem}.post-header{margin:0 auto 6rem}.post-content a{color:#FF0037}.dark .post-content a{color:#FFC107}.post__summary{border-right:3px solid #e7e7e7;color:#555;font-weight:bold;margin-bottom:4rem;padding:4em 2em 1em;position:relative;transition:.25s}.dark .post__summary{border-color:#454545;color:#acacac}.post__summary:before{content:"مخلص کلام";color:#aaa;position:absolute;top:0;right:26px;white-space:nowrap;font-size:1.5714285714rem;line-height:1.2727272727}.dark .post__summary:before{color:gray}.post-meta{color:#888}.dark .post-meta{color:#9e9e9e}.post-tag,.go-top{background-color:#f1f1f1;color:#555;border-radius:3px;display:inline-block;margin-left:0.5em;margin-bottom:1rem;padding:0.3571428571em 0.7142857143em;white-space:nowrap}.dark .post-tag,.dark .go-top{background-color:#2b2b2b;color:#999}.post-tag:hover,.go-top:hover,.post-tag:active,.go-top:active{background-color:#eaeaea;color:#333}.dark .post-tag:hover,.dark .go-top:hover,.dark .post-tag:active,.dark .go-top:active{background-color:#242424;color:#ccc}.go-top{display:inline;margin:0}@media (min-width: 30em) and (max-width: 56.24em){.block-text{display:inline}}@media (min-width: 56.25em){.site-header{margin-bottom:6rem;text-align:initial}[data-page=default] .logo{float:left;margin:0}.site-header>.nav{float:right;padding-top:1.2142857143em}[data-page=default] .nav__item{margin-left:2rem;margin-right:0}.toc li,.post__summary li{margin-bottom:0}}@media (min-width: 64em){.nav__item>a{display:inline-block}.nav__item>a::before{content:''}h1,.h1{font-size:2.1428571429rem;line-height:1.8666666667}h2,.h2{font-size:1.8571428571rem;line-height:2.1538461538}h3,.h3{font-size:1.5714285714rem;line-height:2.5454545455}h4,.h4{font-size:1.2857142857rem;line-height:1.5555555556}.post-content p{font-size:1.1428571429rem;line-height:1.75}}@media (max-width: 29.99em){.site-header .nav__item{margin-bottom:1rem}.post-meta{line-height:3}}
</style> <script id=loadCSS__main>
		// load CSS fonts and icons asynchronously
		!function(a){"use strict";a.loadCSS=function(b,c,d){var e,f=a.document,g=f.createElement("link");if(c)e=c;else{var h=(f.body||f.getElementsByTagName("head")[0]).childNodes;e=h[h.length-1]}var i=f.styleSheets;g.rel="stylesheet",g.href=b,g.media="only x",e.parentNode.insertBefore(g,c?e:e.nextSibling);var j=function(a){for(var b=g.href,c=i.length;c--;)if(i[c].href===b)return a();setTimeout(function(){j(a)})};return g.onloadcssdefined=j,j(function(){g.media=d||"all"}),g}}(this);
		loadCSS( "/assets/styles/main.css", false, "all" );
	</script> <noscript> <link rel=stylesheet href=/assets/styles/main.css> </noscript> <script id=loadLocalStorageCSS__webfonts>"use strict";function loadFont(a,b,c,d){function e(){if(!("FontFace"in window))return!1;var a=new FontFace("t",'url( "data:application/font-woff2;base64,d09GMgABAAAAAAIkAAoAAAAABVwAAAHcAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlYAgloKLEoBNgIkAxgLDgAEIAWDcgc1G7IEyB6SJAFID5YA3nAHC6h4+H7s27nP1kTyOoQkGuJWtNGIJKYznRI3VEL7IaHq985ZUuKryZKcAtJsi5eULwUybm9KzajBBhywZ5ZwoJNuwDX5C/xBjvz5DbsoNsvG1NGQiqp0NMLZ7JlnW+5MaM3HwcHheUQeiVokekHkn/FRdefvJaTp2PczN+I1Sc3k9VuX51Tb0Tqqf1deVXGdJsDOhz0/EffMOPOzHNH06pYkDDjs+P8fb/z/8n9Iq8ITzWywkP6PBMMN9L/O7vY2FNoTAkp5PpD6g1nV9WmyQnM5uPpAMHR2fe06jbfvzPriekVTQxC6lpKr43oDtRZfCATl5OVAUKykqwm9o8R/kg37cxa6eZikS7cjK4aIwoyh6jOFplhFrz2b833G3Jii9AjDUiAZ9AxZtxdEYV6imvRF0+0Nej3wu6nPZrTLh81AVcV3kmMVdQj6Qbe9qetzbuDZ7vXOlRrqooFSxCv6SfrDICA6rnHZXQPVcUHJYGcoqa3jVH7ATrjWBNYYkEqF3RFpVIl0q2JvMOJd7/TyjXHw2NyAuJpNaEbz8RTEVtCbSH7JrwQQOqwGl7sTUOtdBZIY2DKqKlvOmPvUxJaURAZZcviTT0SKHCXqzwc=" ) format( "woff2" )',{});return a.load()["catch"](function(){}),"loading"==a.status||"loaded"==a.status}var f={};try{f=localStorage||{}}catch(g){}var h="x-font-"+a,i=h+"_file",j=h+"_content",k=f[i],l=f[j],m=document.createElement("style");if(m.rel="stylesheet",document.head.appendChild(m),!l||k!==b&&k!==c){var n=c&&e()?c:b,o=new XMLHttpRequest;o.open("GET",n),o.onload=function(){o.status>=200&&o.status<400&&(f[i]=n,f[j]=m.textContent=o.responseText)},o.send()}else m.textContent=l};loadFont('IranSansLight', '/assets/fonts/iranian-sans/iran-sans-light-v4-woff.css','/assets/fonts/iranian-sans/iran-sans-light-v4-woff2.css')</script> <link rel=dns-prefetch href=//www.google-analytics.com>  <meta name=robots content=index,follow> <meta name=revisit-after content="1 days">   <meta name=application-name content=naser.dev> <meta name=apple-mobile-web-app-capable content=yes> <meta name=apple-mobile-web-app-status-bar-style content=#0081D2> <meta id=theme-color name=theme-color content=#0081D2>   <!--[if lt IE 10]><link rel="shortcut icon" href="/favicon.ico"><![endif]-->  <link rel=icon sizes=192x192 href=/assets/images/fav/android-touch-icon.png> <link rel=icon sizes=180x180 href=/assets/images/fav/apple-touch-icon.png> <link rel=apple-touch-icon sizes=180x180 href=/assets/images/fav/apple-touch-icon.png> <link rel=apple-touch-icon-precomposed sizes=180x180 href=/assets/images/fav/apple-touch-icon.png>  <meta name=msapplication-TileImage content=/assets/images/fav/tile.png> <meta name=msapplication-TileColor content=#fff>  <meta name=msapplication-config content=browserconfig.xml>  <meta property=og:locale content=fa> <meta property=og:title content="مرورگرها چگونه کار می‌کنند؟"> <meta property=og:type content=article> <meta property=og:url content="https://naser.dev/blog/2015/how-browsers-work/"> <meta property=og:description content="مرورگرهای وب جزء پر استفاده ترین نرم افزارهای هستند، که تا به حال به دست بشر ساخته شده‌اند. به همین منظور، سفر اکتشافی خواهیم داشته، به اعماق این موجودات؛ تا..."> <meta property=og:site_name content=naser.dev> <meta property=og:image content=https://naser.dev/assets/images/content/2015/12/webkit-logo.png>  <meta name=twitter:card content=summary> <meta name=twitter:site content=@snhasani> <meta name=twitter:title content="مرورگرها چگونه کار می‌کنند؟"> <meta name=twitter:description content="مرورگرهای وب جزء پر استفاده ترین نرم افزارهای هستند، که تا به حال به دست بشر ساخته شده‌اند. به همین منظور، سفر اکتشافی خواهیم داشته، به اعماق این موجودات؛ تا..."> <meta property=twitter:image content=https://naser.dev/assets/images/content/2015/12/webkit-logo.png> <meta name=twitter:creator content=@snhasani> </head> <body id=top data-page=default> <div class=page-wrapper> <header class="site-header container text-center clearfix"> <a class="logo mb-half" href="/"><svg viewbox="0 0 220 33"><g id=naser><path d="M0 9.368c1.08-.264 2.148-.468 3.204-.612 1.08-.144 2.088-.216 3.024-.216 2.232 0 3.912.576 5.04 1.728 1.152 1.152 1.728 3 1.728 5.544v9.792h-2.952v-9.252c0-1.08-.096-1.956-.288-2.628-.192-.672-.468-1.188-.828-1.548-.336-.384-.756-.648-1.26-.792-.48-.144-1.008-.216-1.584-.216-.48 0-.996.036-1.548.108-.528.048-1.044.12-1.548.216v14.112H0V9.368"></path><path d="M22.624 23.48c.744 0 1.404-.024 1.98-.072.6-.048 1.092-.108 1.476-.18V18.26c-.384-.12-.852-.216-1.404-.288-.528-.072-1.092-.108-1.692-.108-.552 0-1.092.048-1.62.144-.528.072-.996.216-1.404.432-.408.216-.744.504-1.008.864-.264.336-.396.768-.396 1.296 0 1.08.36 1.836 1.08 2.268.744.408 1.74.612 2.988.612m-.288-14.976c1.248 0 2.292.156 3.132.468.864.312 1.56.744 2.088 1.296s.9 1.224 1.116 2.016c.216.792.324 1.656.324 2.592v10.44c-.696.12-1.62.264-2.772.432-1.128.168-2.292.252-3.492.252-.912 0-1.8-.084-2.664-.252-.864-.144-1.632-.408-2.304-.792-.672-.408-1.212-.96-1.62-1.656s-.612-1.584-.612-2.664c0-.96.204-1.764.612-2.412.432-.672.972-1.212 1.62-1.62.672-.408 1.428-.696 2.268-.864.864-.192 1.728-.288 2.592-.288 1.176 0 2.328.132 3.456.396v-.828c0-.504-.06-.984-.18-1.44-.096-.48-.3-.912-.612-1.296-.288-.384-.696-.684-1.224-.9-.504-.24-1.164-.36-1.98-.36-1.032 0-1.932.072-2.7.216-.768.144-1.356.288-1.764.432l-.36-2.448c.408-.192 1.08-.36 2.016-.504.96-.144 1.98-.216 3.06-.216"></path><path d="M42.08 21.428c0-.6-.252-1.092-.756-1.476-.48-.384-1.092-.72-1.836-1.008-.72-.288-1.512-.564-2.376-.828-.864-.288-1.668-.636-2.412-1.044-.72-.408-1.332-.912-1.836-1.512-.48-.6-.72-1.38-.72-2.34 0-1.344.54-2.46 1.62-3.348 1.104-.912 2.82-1.368 5.148-1.368.912 0 1.848.072 2.808.216.984.12 1.824.288 2.52.504l-.54 2.664c-.192-.096-.456-.192-.792-.288-.336-.12-.72-.216-1.152-.288-.432-.096-.9-.168-1.404-.216-.48-.048-.948-.072-1.404-.072-2.592 0-3.888.708-3.888 2.124 0 .504.24.936.72 1.296.504.336 1.128.648 1.872.936.744.288 1.548.588 2.412.9.864.288 1.668.648 2.412 1.08.744.432 1.356.96 1.836 1.584.504.6.756 1.368.756 2.304 0 1.512-.588 2.688-1.764 3.528-1.176.816-3.036 1.224-5.58 1.224-1.152 0-2.208-.096-3.168-.288s-1.872-.48-2.736-.864l.576-2.7c.84.384 1.716.708 2.628.972.936.24 1.932.36 2.988.36 2.712 0 4.068-.684 4.068-2.052"></path><path d="M54.768 8.504c2.256 0 3.996.708 5.22 2.124 1.224 1.392 1.836 3.516 1.836 6.372v1.044H49.872c.12 1.728.684 3.048 1.692 3.96 1.032.888 2.472 1.332 4.32 1.332 1.056 0 1.956-.084 2.7-.252.744-.168 1.308-.348 1.692-.54l.396 2.52c-.36.192-1.008.396-1.944.612-.936.216-1.992.324-3.168.324-1.44 0-2.712-.216-3.816-.648-1.08-.456-1.98-1.068-2.7-1.836s-1.26-1.68-1.62-2.736c-.36-1.08-.54-2.244-.54-3.492 0-1.488.228-2.784.684-3.888s1.056-2.016 1.8-2.736c.744-.72 1.584-1.26 2.52-1.62.936-.36 1.896-.54 2.88-.54m4.032 7.128c0-1.416-.372-2.532-1.116-3.348-.744-.84-1.728-1.26-2.952-1.26-.696 0-1.332.132-1.908.396-.552.264-1.032.612-1.44 1.044-.408.432-.732.924-.972 1.476-.24.552-.396 1.116-.468 1.692H58.8"></path><path d="M65.296 25.604V9.8c2.448-.84 4.92-1.26 7.416-1.26.768 0 1.5.036 2.196.108.696.048 1.464.168 2.304.36l-.54 2.628c-.768-.216-1.452-.348-2.052-.396-.576-.072-1.212-.108-1.908-.108-1.464 0-2.952.204-4.464.612v13.86h-2.952"></path></g><path class=logo__atsign d="M102.5 25.944c-.768 0-1.404-.108-1.908-.324-.504-.216-.924-.504-1.26-.864-.528.288-1.164.54-1.908.756-.744.192-1.488.288-2.232.288-1.152 0-2.208-.18-3.168-.54-.936-.36-1.752-.888-2.448-1.584-.696-.72-1.236-1.596-1.62-2.628-.384-1.032-.576-2.232-.576-3.6 0-1.152.18-2.232.54-3.24.36-1.032.888-1.92 1.584-2.664.72-.768 1.584-1.368 2.592-1.8 1.032-.432 2.196-.648 3.492-.648 1.224 0 2.34.096 3.348.288 1.032.192 1.824.384 2.376.576v11.016c0 .768.132 1.308.396 1.62.264.312.612.468 1.044.468.624 0 1.164-.216 1.62-.648.48-.432.864-.996 1.152-1.692.312-.696.54-1.476.684-2.34.144-.888.216-1.788.216-2.7 0-1.512-.264-2.928-.792-4.248-.528-1.344-1.284-2.52-2.268-3.528-.984-1.008-2.184-1.8-3.6-2.376-1.392-.576-2.964-.864-4.716-.864-1.752 0-3.36.3-4.824.9-1.464.576-2.724 1.416-3.78 2.52-1.052 1.08-1.88 2.412-2.48 3.996-.576 1.584-.864 3.384-.864 5.4 0 2.112.312 3.972.936 5.58.624 1.584 1.488 2.916 2.592 3.996 1.128 1.056 2.448 1.848 3.96 2.376 1.536.552 3.216.828 5.04.828 1.416 0 2.58-.084 3.492-.252.936-.168 1.536-.3 1.8-.396l.36 2.664c-.408.144-1.152.3-2.232.468-1.056.168-2.196.252-3.42.252-2.136 0-4.152-.312-6.048-.936-1.9-.6-3.556-1.536-4.972-2.808-1.416-1.248-2.544-2.844-3.384-4.788C80.408 22.5 80 20.172 80 17.484c0-2.592.408-4.86 1.224-6.804s1.908-3.552 3.276-4.824c1.392-1.296 2.988-2.268 4.788-2.916 1.824-.648 3.744-.972 5.76-.972 1.968 0 3.828.324 5.58.972 1.752.624 3.288 1.548 4.608 2.772 1.32 1.2 2.364 2.664 3.132 4.392.768 1.704 1.152 3.636 1.152 5.796 0 1.632-.192 3.072-.576 4.32-.36 1.248-.852 2.304-1.476 3.168-.624.84-1.368 1.476-2.232 1.908-.864.432-1.776.648-2.736.648m-7.2-2.916c.504 0 1.008-.048 1.512-.144.528-.12.996-.288 1.404-.504-.072-.312-.12-.624-.144-.936-.024-.312-.036-.612-.036-.9v-8.46c-.144-.048-.42-.096-.828-.144-.408-.048-.864-.072-1.368-.072-1.704 0-2.976.528-3.816 1.584-.84 1.056-1.26 2.388-1.26 3.996 0 1.704.408 3.06 1.224 4.068.816 1.008 1.92 1.512 3.312 1.512"></path><g id=earth><path d="M120.88 8.504c2.256 0 3.996.708 5.22 2.124 1.224 1.392 1.836 3.516 1.836 6.372v1.044h-11.952c.12 1.728.684 3.048 1.692 3.96 1.032.888 2.472 1.332 4.32 1.332 1.056 0 1.956-.084 2.7-.252.744-.168 1.308-.348 1.692-.54l.396 2.52c-.36.192-1.008.396-1.944.612-.936.216-1.992.324-3.168.324-1.44 0-2.712-.216-3.816-.648-1.08-.456-1.98-1.068-2.7-1.836-.72-.768-1.26-1.68-1.62-2.736-.36-1.08-.54-2.244-.54-3.492 0-1.488.228-2.784.684-3.888.456-1.104 1.056-2.016 1.8-2.736.744-.72 1.584-1.26 2.52-1.62.936-.36 1.896-.54 2.88-.54m4.032 7.128c0-1.416-.372-2.532-1.116-3.348-.744-.84-1.728-1.26-2.952-1.26-.696 0-1.332.132-1.908.396-.552.264-1.032.612-1.44 1.044-.408.432-.732.924-.972 1.476-.24.552-.396 1.116-.468 1.692h8.856"></path><path d="M136.74 23.48c.744 0 1.404-.024 1.98-.072.6-.048 1.092-.108 1.476-.18V18.26c-.384-.12-.852-.216-1.404-.288-.528-.072-1.092-.108-1.692-.108-.552 0-1.092.048-1.62.144-.528.072-.996.216-1.404.432-.408.216-.744.504-1.008.864-.264.336-.396.768-.396 1.296 0 1.08.36 1.836 1.08 2.268.744.408 1.74.612 2.988.612m-.288-14.976c1.248 0 2.292.156 3.132.468.864.312 1.56.744 2.088 1.296s.9 1.224 1.116 2.016c.216.792.324 1.656.324 2.592v10.44c-.696.12-1.62.264-2.772.432-1.128.168-2.292.252-3.492.252-.912 0-1.8-.084-2.664-.252-.864-.144-1.632-.408-2.304-.792-.672-.408-1.212-.96-1.62-1.656s-.612-1.584-.612-2.664c0-.96.204-1.764.612-2.412.432-.672.972-1.212 1.62-1.62.672-.408 1.428-.696 2.268-.864.864-.192 1.728-.288 2.592-.288 1.176 0 2.328.132 3.456.396v-.828c0-.504-.06-.984-.18-1.44-.096-.48-.3-.912-.612-1.296-.288-.384-.696-.684-1.224-.9-.504-.24-1.164-.36-1.98-.36-1.032 0-1.932.072-2.7.216-.768.144-1.356.288-1.764.432l-.36-2.448c.408-.192 1.08-.36 2.016-.504.96-.144 1.98-.216 3.06-.216"></path><path d="M147.41 25.604V9.8c2.448-.84 4.92-1.26 7.416-1.26.768 0 1.5.036 2.196.108.696.048 1.464.168 2.304.36l-.54 2.628c-.768-.216-1.452-.348-2.052-.396-.576-.072-1.212-.108-1.908-.108-1.464 0-2.952.204-4.464.612v13.86h-2.952"></path><path d="M168.31 8.9h7.056v2.484h-7.056v7.776c0 .84.06 1.524.18 2.052s.312.96.576 1.296c.288.312.648.528 1.08.648.432.12.96.18 1.584.18.864 0 1.56-.072 2.088-.216.528-.144 1.032-.336 1.512-.576l.432 2.52c-.336.144-.876.336-1.62.576-.72.24-1.62.36-2.7.36-1.248 0-2.268-.144-3.06-.432-.792-.288-1.416-.72-1.872-1.296-.432-.576-.732-1.284-.9-2.124-.168-.864-.252-1.86-.252-2.988v-7.776h-3.528V8.9h3.528V4.22l2.952-.504V8.9"></path><path d="M178.12 25.604V1.16l2.988-.504v8.496c.48-.192 1.02-.336 1.62-.432.6-.12 1.188-.18 1.764-.18 1.272 0 2.328.192 3.168.576.864.36 1.548.876 2.052 1.548s.864 1.476 1.08 2.412c.216.936.324 1.968.324 3.096v9.432h-2.952V16.82c0-2.064-.288-3.516-.864-4.356-.576-.864-1.608-1.296-3.096-1.296-.624 0-1.236.072-1.836.216-.576.12-.996.24-1.26.36v13.86h-2.988"></path></g><path class=logo__underline d="M195 22.8h19.36v2.8H195v-2.8"></path></svg> </a> <nav role=navigation class=nav> <ul class=list> <li class=nav__item><a href="/">صفحه اصلی</a></li> <li class=nav__item><a href="/blog/">وبلاگ</a></li> <li class=nav__item><a href="/about/">درباره من</a></li> </ul> </nav> </header> <div class=mb-double role=main> <article class="post mb-double" itemscope itemtype=http://schema.org/BlogPosting> <header class="post-header text-center container"> <h1 class="post-title mb-half" itemprop="name headline">مرورگرها چگونه کار می‌کنند؟</h1> <p class=post-meta><time datetime=2015-12-17T00:00:00+03:30 itemprop=datePublished>۲۶ آذر ۱۳۹۴</time> توسط <span itemprop=author itemscope itemtype=http://schema.org/Person><a href=/about itemprop=name>ناصر</a></span> در دسته‌ی: <a href=/blog/category/vocation>تخصصی</a></p> </header> <div class=post-content itemprop=articleBody> <p>مرورگرهای وب جزء پر استفاده ترین نرم افزارهای هستند، که تا به حال به دست بشر ساخته شده‌اند. به همین منظور، سفر اکتشافی خواهیم داشته، به اعماق این موجودات؛ تا ببینیم چه اتفاقی در پس پرده‌ی آن‌ها و موتورهای رندرشان در حال رخ دادن است.</p> <div class=container> <div class=post__summary> <p>مرورگرهای متداولی که ما روزانه با آنها سر و کار داریم، از ۷ بخش عمده تشکیل شده اند که اصلی ترین بخش آن‌ها، موتور رندرشان است. وظیفه‌ی این موتور، رندر محتوای صفحات دریافتی از سرور و پاسخگویی به تغییرات آینده است. فرآیند رندر شامل چهار مرحله‌‌ی عمده زیر می‌شود:</p> <ol> <li>تجزیه و ترجمه HTML و تبدیل آن به درخت DOM</li> <li>تشکیل درخت رندر براساس درخت DOM و درخت استایل</li> <li>صفحه بندی عناصر درخت رندر</li> <li>رسم و رنگرزی حالت گرافیکی اشیای درخت رندر</li> </ol> <p>بعد از طی این چهار مرحله است که کاربر می‌توان محتوای درخواستی خود را بر روی صفحه نمایشگرش ببیند.</p> </div> <h4 id=section>فهرست مطالب</h4> <ol class=toc> <li><a href=#intro>مقدمه</a> <ol> <li><a href=#the-browsers-we-will-talk-about>مقصدمان کدام مرورگرها هستند؟</a></li> <li><a href=#the-browser-high-level-structure>یک مرورگر از چه اجزایی تشکیل شده است؟</a></li> </ol> </li> <li><a href=#the-rendering-engine>موتور رندر</a> <ol> <li><a href=#rendering-engines>انواع موتورهای رندر</a></li> <li><a href=#browser-rendering-main-flow>چرخه اصلی فرآیند رندر یک صفحه‌ی HTML</a></li> <li><a href=#browser-rendering-main-flow-examples>مثال‌های شماتیکی از فرآیند اصلی رندر</a></li> <li><a href=#parsing>تشکیل درخت DOM</a> <ol> <li><a href=#parsing>تجزیه «Parsing»</a> <ol> <li><a href=#what-is-parsing>تجزیه یا پارسینگ چیست؟</a></li> <li><a href=#grammer>گرامر</a></li> <li><a href=#parser-lexer-combination>تشکیل درخت تجزیه</a></li> <li><a href=#translation>ترجمه</a></li> <li><a href=#formal-definitions-for-vocabulary-and-syntax>تعاریف ثابت برای لغات و قواعد</a></li> <li><a href=#types-of-parsers>انواع تجزیه‌گرها</a></li> <li><a href=#generating-parsers-automatically>ایجاد خودکار تجزیه‌گرها</a></li> </ol> </li> <li><a href=#html-parser>تجزیه‌گر HTML</a> <ol> <li><a href=#the-html-grammar-definition>گرامر تعریف شده‌ی زبان HTML</a></li> <li><a href=#not-a-context-free-grammar>چرا گرامر HTML بدون چارچوب است؟!</a></li> <li><a href=#html-dtd>HTML <abbr title="Document Type Definition">DTD</abbr></a></li> <li><a href=#dom>DOM</a></li> <li><a href=#the-parsing-algorithm>الگوریتم تجزیه HTML</a></li> <li><a href=#actions-when-the-parsing-is-finished>چه اتفاق‌هایی بعد از اتمام تجزیه HTML رخ می‌دهد؟</a></li> <li><a href=#browsers-error-tolerance>چرا مرورگرها از خطاهای HTML‌ می‌گذرند؟!</a></li> </ol> </li> <li><a href=#css-parsing>تجزیه‌گر CSS</a> <ol> <li><a href=#webkit-css-parser>تجزیه‌گر CSS موتور وب‌کیت</a></li> </ol> </li> <li><a href=#the-order-of-processing-scripts-and-style-sheets>ترتیب پردازش اسکریپت‌ها و برگه‌های استایل</a> <ol> <li><a href=#scripts>اسکریپت‌ها</a></li> <li><a href=#style-sheets>برگه‌های استایل</a></li> <li><a href=#speculative-parsing>تجزیه‌ی موازی</a></li> </ol> </li> </ol> </li> <li><a href=#render-tree-construction>ساخت درخت رندر</a> <ol> <li><a href=#the-render-tree-relation-to-the-dom-tree>رابطه درخت رندر با درخت DOM</a></li> <li><a href=#the-flow-of-constructing-the-tree>فرآیند ساخت درخت رندر</a></li> <li><a href=#style-computation>محاسبه‌ی استایل</a></li> <li><a href=#css-gradual-process>فرآیند تدریجی و گام به گام تجزیه‌ی CSS</a></li> </ol> </li> <li><a href=#layout>صفحه بندی «layout»</a> <ol> <li><a href=#dirty-bit-system>سیستم کمی آلوده (“dirty bit”)</a></li> <li><a href=#global-and-incremental-layout>صفحه بندی: تدریجی و عمومی</a></li> <li><a href=#asynchronous-and-synchronous-layout>صفحه بندی: ترتیبی و موازی</a></li> </ol> </li> <li><a href=#painting>رنگرزی «painting»</a> <ol> <li><a href=#global-and-incremental-painting>انواع فرآیندهای رنگرزی: عمومی و تدریجی</a></li> <li><a href=#the-painting-order>ترتیب اولویت‌های رنگرزی</a></li> </ol> </li> <li><a href=#dynamic-changes>انعطاف در برابر تغییرات</a></li> <li><a href=#the-rendering-engine-threads>جریان‌های موتور رندر کننده</a> <ol> <li><a href=#event-loop>حلقه‌ی رخداد</a></li> </ol> </li> </ol> </li> <li><a href=#last-words>سخن پایانی</a></li> </ol> <h2 id=intro>مقدمه</h2> <p>مرورگرهای وب، امروزه دیگر همه‌جا هستند؛ و یکی از اصلی‌ترین نرم افزارهایی هستند که اغلب ما در طول روز با آن‌ها سر و کار داریم. محتوای آن‌ها، صفحات وب و برنامه‌های تحت وبی هستند که در نتیجه تلاش مداوم توسعه دهندگان وب ایجاد می‌شوند. وجود آن‌ها به همان اندازه‌ای که برای مصرف کنندگان این محتوا حیاتی است، برای تولید کنندگانش نیز هست.</p> <p>از دیر باز، در هر عرصه‌ای، از صنعت گرفته تا هنر، مرز باریکی بین خلاقیت، تقلید و تکرار منفعلانه وجود داشته است. در این بین، افرادی که توانسته‌اند از این مرز عبور کنند، نام‌شان را در طول تاریخ، جاودانه کرده‌اند. پیش نیاز خلاقیت و ابداع، دانش و درک عمیق است. هر چقدر این درک و دانش نسبت به اصول اولیه، ابزار و فنون بالاتر رود، جسارت برای تغییر و نوآوری نیز در شخص، بالاتر می‌رود.</p> <p>استاد کاری که نتواند ابزار کار خود را به حد کفایت بشناسد، ناخواسته به بردگی آن تن خواهد داد؛ و در صورت عکس ماجرا، این ابزار است که رام استاد کار خواهد شد و تحت کنترل آن در خواهد آمد. حال هر چه تسلط یک توسعه دهنده‌ی وب بر روی این مرورگرهای آن بیشتر باشد، از طرفی با جسارت بیشتری می‌تواند دست به طراحی و تخیل بزند؛ و از طرف دیگر در مواجه با چالش‌های گوناگون پیش بینی نشده در طول کار، با اعتماد بنفس بیشتری با آن‌ها درگیر می‌شود.</p> <p>در طول سال‌های متمادی که IE سهم نود درصدی از میزان استفاده از مرورگرها را در دست داشت، چیز زیادی از آن‌ها نمی‌دانستیم و به صورت یک جعبه‌ی سیاه باقی مانده بودند. اما بعد از ورود شکوهمندانه‌ی مرورگرهای متن باز و حالا با کسب بیش از ۷۵ درصدی سهم بازار، زمان مناسبی رسیده بود تا سرکی به پشت پرده‌ی موتورهای این مرورگرها بیندازیم و ببینیم چه چیزی در میان آن چند میلیون خط کد ++C در جریان است.</p> <h3 id=the-browsers-we-will-talk-about>مقصدمان کدام مرورگرها هستند؟</h3> <p>در حال حاضر ۵ مرورگر اصلی که در سیستم عامل‌های رومیزی استفاده می‌شوند، عبارتند از: گوگل کروم، موزیلا فایرفاکس، ماکروسافت اینترنت اگسپلورر، اپل سافاری و اُپرا. در سیستم عامل‌های همراه نیز مرورگرهای اصلی عبارتند از: مرورگر اندروید، آیفون، ویندوز فون، اُپرا مینی، اُپرا موبایل، مرورگر UC، مرورگرهای s40/s60 نوکیا و کروم - که همه آنها به جز مرورگرهای ویندوز فون و اپرا بر اساس موتور WebKit پیاده سازی شده‌اند.</p> <p>متن پیش رو بر اساس مرورگرهای اوپن سورس فایرفاکس، کروم و سافاری(که فقط بخشی‌هایی از آن اوپن سورس است) تنظیم شده است. در حال حاضر این مرورگرها به شهادت آمار سایت <a href="http://gs.statcounter.com/">StatCounter</a> در ۳ ماهه‌ی پاییز ۱۳۹۴ در ایران، به طور میانگین بیش از ۷۵ درصد سهام بازار مرورگرها را در تمامی دستگاه‌های رومیزی و همراه در اختیار دارند.</p> <figure class="lazy text-center"> <img src=/assets/images/placeholder.png data-layzr=/assets/images/content/2015/12/StatCounter-browser-IR-quarterly-q4-2015-bar.jpg alt=StatCounter-browser-IR-quarterly-q4-2015-barStatCounter-browser-IR-quarterly-q4-2015-bar> <figcaption>نمودار درصد سهم مرورگرها از بازار ایران در پاییز ۱۳۹۴</figcaption> </figure> <h3 id=the-browser-high-level-structure>یک مرورگر از چه اجزایی تشکیل شده است؟</h3> <p>اجزایی اصلی یک مرورگر وب عبارتند از:</p> <ol> <li><strong>رابط کاربری (<abbr title="User Interface">UI</abbr>)</strong>: این لایه شامل آدرس بار، دکمه‌های عقب و جلو، منوی بوکمارک و غیره است. در کل این رابط به جز قالب پنجره‌ی مرورگر (یعنی همان ۳-۴ دکمه‌ای که در گوشه‌ی بالایی سمت راست یا چپ کادر در برگیرنده‌ی مرورگر خود می‌بینید) را شامل می‌شود. که این یعنی تمامی بخش‌های ظاهری مرورگر و عناصر موجود در محتوای درخواستی کاربر که به عنوان یک صفحه‌ی وب نمایش داده می‌شود.</li> <li><strong>موتور مرورگر</strong>: مسول اصلی رسیدگی به عملیات‌های صورت گرفته بین لایه‌های <abbr title="User Interface">UI</abbr> و موتور رندر است.</li> <li><strong>موتور رندر</strong>: مسولیت نمایش محتوای درخواست شده بر عهده‌ی ایشان است. برای مثال اگر محتوای درخواست شده یک سند HTML باشد، موتور رندر کدهای HTML و CSS مربوطه را بعد از تجزیه کردن (Parse) بر روی صفحه نمایش کاربر، همان طور که در حال حاضر در حال خواندن این جملات هستید، نمایش می‌دهد.</li> <li><strong>شبکه</strong>: مسول عملیات‌های شبکه‌ای مانند یک در خواست <abbr title="The Hypertext Transfer Protocol">HTTP</abbr> است. ایشان علاوه بر اینکه خود یک رابط (Interface) مستقل از پلتفرم هستند، از پیاده سازی‌های مختلفی نیز در پلتفرم‌های مختلف، در لایه‌های پایین‌تر از خود استفاده می‌کند.</li> <li><strong>بستر رابط کاربری (<abbr title="User Interface">UI</abbr> backend)</strong>: به منظور رسم و نمایش عناصری مثل کومبو باگس‌ها، دکمه‌ها، فیلدها و غیره استفاده می‌شوند. این لایه هم مثل لایه‌ی شبکه از یک رابط عمومی بهره می‌برد که مختص پلتفرم خاصی نیست؛ ولی در سطوح پایین از متدهای رابط کاربری مختص همان پلتفرم هم استفاده می‌کند.</li> <li><strong>مترجم جاوا اسکریپت</strong>: همان طور که از اسمش معلوم است، وظیفه‌ی تجزیه و اجرای کدهای جاوا اسکریپت را بر عهده دارد.</li> <li><strong>انباره داده‌ها (Data Storage)</strong>: این لایه وظیفه‌ی نگهداری از تمامی انواع داده‌های مرورگر از قبیل، کوکی‌ها، session-ها و غیره را بر عهده دارد. و نیز عهده دار مدیریت مکانیزم‌های دیگر نگهداری و پالایش داده‌ها نظیر LocalStorage، IndexedDB، WebSQL و FileSystem نیز هست.</li> </ol> <figure class="lazy text-center"> <img src=/assets/images/placeholder.png data-layzr=/assets/images/content/2015/12/browser-components.png alt="اجزای اصلی مرورگرها"> <figcaption>اجزای اصلی مرورگرها</figcaption> </figure> <p>این نکته‌ی مهم را در نظر داشته باشید که مرورگرهای مانند کروم، نمونه‌های (Instance) متعددی از موتور رندر خود را هم زمان اجرا می‌کنند. یعنی برای هر تب، یک موتور رندر؛ که هر تب فرآیند(Process) جداگانه‌ی خود را دارد. (می‌توانید با فشار دادن همزمان کلیدهای ترکیبی shift+Esc در مرورگر کروم خود به راحتی فرآیند‌های در حال اجرا توسط آن را مشاهده کنید.)</p> <h2 id=the-rendering-engine>موتور رندر</h2> <p>همان طور که قبلا اشاره شد، مسولیت موتور رندر، رندر کردن است؛ که این می‌شود نمایش محتوای درخواست شده از سمت کاربر نهایی، درون پنجره‌ی مرورگر.</p> <p>به طور پیش فرض موتورهای رندر کننده‌ قادر هستند تا سندهای HTML، <abbr title="Extensible Markup Language">XML</abbr> و تصاویر را نمایش دهند. البته آن‌ها علاوه بر این قسم از منابع، قادرند اسناد PDF و غیره را نیز به واسطه‌ی نصب پلاگین‌های مربوطه نمایش دهند (هر چند مرورگرهای مدرن امروزی بسیاری از پلاگین‌های دیروزی مانند همین PDF خوان را در خود به صورت توکار تعبیه کرده‌اند). در هر صورت در این فصل تماماْ بر روی نحوه‌ی رندر و نمایش اسناد HTML‌ و تصاویر که به وسیله‌ی CSS نقاشی شده‌اند، تمرکز خواهیم کرد.</p> <h3 id=rendering-engines>انواع موتورهای رندر</h3> <p>مرورگرهای مختلف، از موتورهای رندر کننده‌ی مختلفی نیز استفاده می‌کنند. به طوری که:</p> <ul> <li>اینترنت اگسپلورر: Trident</li> <li>فایرفاکس: Gecko</li> <li>سافاری: WebKit</li> <li>کروم و اُپرا (از نسخه‌ی ۱۵): ‌Blink (شاخه‌ای از وب‌کیت است که توسط گوگل منشعب شده)</li> </ul> <p>استفاده می‌کنند.</p> <p>وب‌کیت یک موتور رندر کننده‌ی متن باز است که در ابتدا به منظور استفاده در پلتفرم لینوکس کلید خورد و بعد‌ها توسط شرکت اپل به منظور استفاده در پلتفرم‌های مک و ویندوز ویرایش شد. برای جزییات بیشتر می‌توایند به <a href="https://webkit.org/">وب سایت</a> خود این موتور که به تازگی هم باز طراحی شده مراجعه کنید.</p> <h3 id=browser-rendering-main-flow>چرخه اصلی فرآیند رندر یک صفحه‌ی HTML</h3> <p>موتور رندر کننده کار خودش را درست از زمانی آغاز می‌کند که محتوای درخواست شده توسط لایه‌ی شبکه، از سرور تحویل گرفته شده باشد. این اطلاعات به طور معمولی در قطعات ۸ کیلوبایتی از سمت سرور تحویل داده می‌شوند.</p> <p>پس از رسیدن داده‌ها، موتور رندر چهار مرحله‌ای را که در تصویر زیر مشاهده می‌کنید را به ترتیب برای هر درخواست در هر بار باید طی کند تا سند درخواستی کاربر برایش در پنچره مرورگر قابل مشاهده و استفاده شود.</p> <figure class="lazy text-center"> <img src=/assets/images/placeholder.png data-layzr=/assets/images/content/2015/12/rendering-engine-basic-flow.png alt="جریان اصلی عملیات انجام شده توسط موتور رندر مرورگر"> <figcaption>چرخه اصلی فرآیند رندر یک صفحه‌ی HTML توسط موتور رندر مرورگرها</figcaption> </figure> <p>موتور رندر کننده با تجزیه و تبدیل سند HTML‌ به گره‌های (node) درختی به نام «درخت محتوا» کار خود را آغاز می‌کند. موتور هم چنین داده‌های مربوط به برگه‌های استایل (stylesheet) این گره‌ها را نیز تجزیه می‌کند که شامل تمامی انواع استایل‌ها، از خارجی (external) گرفته تا درونی (inline) می‌شود. این اطلاعات بدست آماده از تجزیه داده‌های استایل‌ها به همراه دستورات گرافیکی آمده در سند HTML توسط موتور رندر برای ساخت یک درخت دیگر، به نام «درخت رندر» استفاده می‌شود.</p> <p>درخت رندر، شامل نواحی مستطیلی شکلی است که مشخص کننده‌ی مختصات هر عنصر در صفحه و خصوصیات آنها مانند رنگ، نوع و اندازه قلم و غیره است. این نواحی درست به ترتیبی که قرار است این عناصر بر روی صفحه نمایش نقش ببندند، بر روی درخت از بالا به پایین چیده می‌شوند.</p> <p>بعد ساخته شدن درخت رندر، موتور به سراغ فرآیند صفحه بندی (layout) عناصر می‌رود. بدان معنی که به هر یک از گره‌های درخت رندر، نسبت به اندازه و مختصات دیگر گره‌های درخت، یک مختصات (طول و عرض و عمق) مخصوص می‌دهد که باید دقیقا بر اساس آن بر روی صفحه ظاهر شوند.</p> <p>مرحله‌ی بعدی رنگرزی (painting) است. هر کدام از گره‌های درخت رندر در اینجا به وسیله‌ی لایه‌ی بستر رابط کاربری (<abbr title="User Interface">UI</abbr> backend) رنگ و لعاب داده می‌شوند. یعنی همان پوسته‌ی ظاهری که ما بر روی صفحه نمایش می‌توانیم به عنوان خروجی ببینیم، در این مرحله صورت می‌پذیرد.</p> <p>این نکته‌ی مهم را در نظر داشته باشید که این چهار مرحله گفته شده، یک فرآیند پیش رونده تدریجی و بلادرنگ است. به این معنی که به منظور حصول یک تجربه کاربری دلپذیر برای کاربر، موتور رندر سعی می‌کند که به محض آماده شدن اولین سری از داده‌ها از سمت سرور و دریافت آن‌ها، فرآیند رندر را شروع کند؛ و به انتظار دریافت کامل اطلاعات نشیند. در این شیوه موتور رندر هر بخش از کدهای HTML‌ که به دستش می‌رسد را شروع به تجزیه می‌کند و فرآیند را تا به مرحله آخر، یعنی نمایش داده‌های ورودی در صفحه نمایش ادامه می‌دهد. این عمل را تا جایی تکرار می‌کند که به انتهای کد‌های HTML‌ دریافتی برسد.</p> <h3 id=browser-rendering-main-flow-examples>مثال‌های شماتیکی از فرآیند اصلی رندر</h3> <figure class="lazy text-center"> <img src=/assets/images/placeholder.png data-layzr=/assets/images/content/2015/12/WebKit-engine-main-flow.png alt="فرآیند اصلی رندر در موتور WebKit"> <figcaption>فرآیند اصلی رندر در موتور WebKit</figcaption> </figure> <figure class="lazy text-center"> <img src=/assets/images/placeholder.png data-layzr=/assets/images/content/2015/12/firefox-Gecko-rendering-engine-main-flow.png alt="فرآیند اصلی رندر در موتور Gecko موزیلا"> <figcaption>فرآیند اصلی رندر در موتور Gecko موزیلا</figcaption> </figure> <p>همان طور که در دو تصویر فوق می‌بینید، دو موتور وب‌کیت و گِکو تفاوت مختصری از نظر لغوی و صرفا نام‌گذاری مراحل دارند و عملا فرآیند اصلی در هر دو یکسان است.</p> <p>گِکو درخت عناصری که مشخصات ظاهریشان تعیین شده است را <strong>درخت فریم</strong> «Frame tree» می‌نامند؛ و به هر عنصر یا گره‌ی درخت یک فریم می‌گویید. این در حالی است که همان طور که گفته شد وب‌کیت به این درخت، «<strong>درخت رندر</strong>» می‌گویید؛ که از <strong>اشیای رندر</strong> «Render Objects» تشکیل شده می‌شود. در جای دیگر هم وب کیت از اصطلاح <strong>صفحه بندی</strong> «layout» برای مشخص کردن مختصات عناصر در صفحه استفاده می‌کند؛ در حالی که گِکو آن را <strong>باز جانمایی</strong> «reflow» می‌نامند.</p> <p>وب‌کیت از اصطلاح <strong>ضمیمه</strong> «Atachment» برای مرحله‌ای که گره‌های DOM‌ را با خصوصیات گرافیکی استخراجی مرتبط‌شان از CSS می‌خواهد ترکیب کند، استفاده می‌کند. یک تفاوت غیر معنایی(لغوی) جزیی دیگر این است که گِکو یک لایه اضافه بین داده‌های تجزیه شده‌ی HTML و درخت DOM دارد که آن را <strong>حوض محتوا</strong> «content sink» می‌نامد که به صورت یک کارخانه با خط تولید عناصر DOM عمل می‌کند. در ادامه به تفصیل درباره‌ی تمامی بخش‌ها صحبت می‌کنیم.</p> <h3 id=parsing>تجزیه «Parsing»</h3> <h4 id=what-is-parsing>تجزیه چیست؟</h4> <p>تجزیه کردن بیشتر به معنای ترجمه کردن است. به این معنی که ما بیایم یک سند و متنی را که بر اساس یک گرامر معین تنظیم شده است به یک سری ساختار قابل فهم برای ماشین که به آن زبان ماشین نیز گفته می‌شود تجزیه و ترجمه کنیم. نتیجه‌ی این ترجمه معمولا یک درختی از گره‌هایی است که نشان دهنده‌ی ساختار آن سند هستند؛ که به آن درخت تجزیه یا درخت نحو (syntax) نیز می‌گویند.</p> <p>برای مثال، تجزیه‌ی عبارت ۱ - ۳ + ۲ به صورت درخت زیر می‌تواند در بیاید:</p> <figure class="lazy text-center"> <img src=/assets/images/placeholder.png data-layzr=/assets/images/content/2015/12/basic-parsing-mathematical-expression-tree-node.png alt="اگره‌های درخت تجزیه شده‌ی یک عبارت ریاضی"> <figcaption>گره‌های درخت تجزیه شده‌ی یک عبارت ریاضی</figcaption> </figure> <h4 id=grammer>گرامرها</h4> <p>عمل تجزیه بر اساس قواعد نحوی‌ای که از پیش برای هر زبانی تعیین شده است انجام می‌شود. هر فرمتی که قرار است تجزیه شود، باید دارای یک گرامر ثابت، که تشکیل شده از دایره‌ی واژگان آن و قواعد نحوی‌اش باشد. جالب است بدانید که زبان‌های انسانی، جزئ این زبان‌ها نیستند و به همین دلیل نمی‌توان آن‌ها را با تجزیه کنندگان معمولی که داریم تجزیه و تبدیل کنیم.</p> <h4 id=parser-lexer-combination>تشکیل درخت تجزیه</h4> <p>عمل تجزیه کردن به ۲ زیر بخش اصلی «<strong>آنالیز لغوی</strong>» و «<strong>آنالیز نحوی</strong>» تقسیم می‌شود.</p> <p>آنالیز لغوی به فرآیندی اطلاق می‌شود که در آن داده‌های ورودی به اجزای کوچکتری شکسته می‌شوند که به آن‌ها علامت‌های رمزی یا تُکن «Token» می‌گویند. این توکن‌ها همان واژگان تشکیل دهنده‌ی زبان‌ها هستند. آنالیز نحوی نیز همان طور که از نامش بر می‌آید، بر اساس قواعد دستوری زبان سنجیده و استخراج می‌شود.</p> <p>مسولیت عملیات تجزیه بر عهده‌ی ۲ بخش مجزا است. اولی <strong>lexer</strong> (به خوانید لِگزر) (که گاهی نیز به آن «tokenizer» می‌گویند) مسول شکستن داده‌های ورودی به توکن‌های معتبر است و دومی، پارسر/تجزیه‌گر <strong>parser</strong> نام دارد که مسؤل ساخت درخت تجزیه بر پایه‌ی قواعد نحویی زبانی است که داده‌های ورودی با آن تنظیم شده‌اند. هوشمندی لِگزرها در حدی است که کارکترهای زايد مانند فاصله‌ها و خط شکن‌ها را تشخیص دهند.</p> <figure class="lazy text-center"> <img src=/assets/images/placeholder.png data-layzr=/assets/images/content/2015/12/from-source-document-to-parse-trees.png alt="مراحل تبدیل یه سند ورودی به درخت تجزیه شده"> <figcaption>مراحل تبدیل یه سند ورودی به درخت تجزیه شده</figcaption> </figure> <p>تجزیه کردن، یک فرآیند چرخشی و تکرار شونده است. تجزیه‌گر معمولا به لِگزر برای یک توکن جدید درخواست می‌دهد و سپس به دنبال یک قاعده‌ی نحوی مطابق با آن تُکِن می‌گردد. اگر با قاعده‌ای مطابق بود، که گره‌ای را بر روی درخت تجزیه به آن اختصاص می‌دهد؛ و دوباره یک تُکن جدید درخواست می‌کند.</p> <p>در صورتی که هیچ قاعده‌ی نحوی مطابق با تُکن یافت نشود، تجزیه‌گر آن را به صورت یک تُکن داخلی ذخیره می‌کند؛ و به درخواست تُکن‌های بعدی ادامه می‌دهد تا زمانی که همه قواعد مربوط به تمامی تُکن‌های ذخیره شده به صورت داخلی نیز پیدا شود. اگر تُکنی در این مرحله هم چنان بدون قاعده مانده باشد، تجزیه‌گر اعلام خطا می‌کند. این بدان معنی است که سند ورودی معتبر نبوده و در برگیرنده‌ی قواعده‌ی نحوه‌ی اشتباهی است.</p> <h4 id=translation>ترجمه</h4> <p>در بسیاری از موارد، درخت تجزیه شده، محصول نهایی نیست. ورودی تجزیه شده اغلب به مصرف یک مترجم می‌رسد که آن را به فرمت دیگری تبدیل می‌کند. کامپایلر برای تبدیل کد منبع ورودی به کد ماشین نهایی، در ابتدا ورودی را به درخت تجزیه شده تبدیل می‌کند و سپس آن را به کد ماشین ترجمه می‌کند.</p> <figure class="lazy text-center"> <img src=/assets/images/placeholder.png data-layzr=/assets/images/content/2015/12/from-source-document-to-parse-trees.png alt="چرخه‌ی تالیف کد ماشین"> <figcaption>چرخه‌ی تالیف کد ماشین</figcaption> </figure> <p class=notice-quote>حذف شده: <a href=http://taligarsiel.com/Projects/howbrowserswork1.htm#The_parsing_algorithm>تشریح مراحل تشکیل درخت تجزیه و ترجمه آن با مثال عبارات ۱ - ۳ + ۲</a></p> <h4 id=formal-definitions-for-vocabulary-and-syntax>تعاریف ثابت برای لغات و قواعد</h4> <p>لغات معمولا به صورت <a href="http://www.regular-expressions.info/">عبارات باقاعده</a> (regular expressions) بیان می‌شوند. برای مثال زبان ما به صورت زیر تعریف می‌شود.</p> </div> <div class="code-wrapper mb-base"> <div class=container> <pre><code class=language-bash>INTEGER: 0|[1-9][0-9]*
PLUS: +MINUS: -
INTEGER: 0|[1-9][0-9]*PLUS: +
MINUS: -</code></pre> </div> </div> <div class=container> <p>همان طور که می‌بینید، اعداد به صورت عبارات باقاعده تعریف شده اند.</p> <p>قواعد نحوی عموما به صورت فرمتی که آن را <a href=http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form><abbr title="Backus Naur Form">BNF</abbr></a> می‌نامند تعریف می‌شوند. بر اساس این فرمت، زبان ما به این صورت تعریف می‌شود:</p> </div> <div class="code-wrapper mb-base"> <div class=container> <pre><code class=language-bash>expression :=  term  operation
term operation :=  PLUS | MINUS
term := INTEGER | expression</code></pre> </div> </div> <div class=container> <p>در مثال بالا گفته‌ شده که این زبان می‌تواند توسط تجزیه‌گرهای معمول تجزیه شود؛ اگر گرامر آن یک گرامر بدون چارچوب «<a href=http://en.wikipedia.org/wiki/Context-free_grammar>context free grammer</a>» باشد. در یک تعریف سر راست، به گرامری، گرامر با چارچوب آزاد می‌گویند که بتوان آن را به صورت کامل توسط فرمت <abbr title="Backus Naur Form">BNF</abbr> بیان کرد.</p> <h4 id=types-of-parsers>انواع تجزیه‌گرها</h4> <p>دو نوع تجزیه‌گر وجود دارد: تجزیه‌گر «<strong>بالا به پایین</strong>» و «<strong>پایین به بالا</strong>». در یک تعریف کلی، تجزیه‌گر بالا به پایین ساختار بالاترین سطح از قواعد را می‌سنجد و سعی می‌کند تا قاعده منطبق با آن را پیدا کند. در حالی که در تجزیه‌گر پایین به بالا، تجزیه‌گر با ورودی‌ها شروع می‌کند و خُرد خُرد شروع به تبدیل آن‌ها به قواعد نحوی می‌کند؛ یعنی از قواعد سطح پایین شروع می‌کند تا برسد به قواعد سطوح بالاتر. بیاید ببینیم این دو نوع تجزیه‌گر در مواجه با زبانی که پیش‌تر ساختیم چگونه عمل می‌کنند.</p> <p>تجزیه‌گر بالا به پایین، از قواعده‌ای با بالاترین سطح شروع می‌کند: آن داده‌های ۳ + ۲ را به عنوان یک عبارت شناسایی می‌کند. سپس به نوبت به شناسایی ۱ - ۳ +‌۲ می رسد که به عنوان عبارتی بعدی شناسایی می‌شود (فرآیند شناسایی عبارات به صورت تدریجی‌، با تطابق دادن با قواعد دیگر است؛ اما نقطه شروع این سنجش قاعده‌ای با بالاترین مرتبه است).</p> <p>تجزیه‌گر پایین به بالا، شروع به اسکن ورودی می‌کند تا زمانی که با یکی از قواعد منطبق شود. سپس ورودی را با قاعده‌ی منطبق جایگزین می‌کند. این کار را تا جایی ادامه می‌دهد که به انتهای رشته‌ی ورودی‌ برسد. عبارات منطبق موقتی در پشته‌ی تجزیه‌گر قرار می‌گیرند.</p> <table class=ltr> <thead> <tr> <th>Stack</th> <th style="text-align: center">Input</th> </tr> </thead> <tbody> <tr> <td> </td> <td style="text-align: center">2 + 3 - 1</td> </tr> <tr> <td>term</td> <td style="text-align: center">+ 3 - 1</td> </tr> <tr> <td>term operation</td> <td style="text-align: center">3 - 1</td> </tr> <tr> <td>expression</td> <td style="text-align: center">- 1</td> </tr> <tr> <td>expression operation</td> <td style="text-align: center">1</td> </tr> <tr> <td>expression</td> <td style="text-align: center">-</td> </tr> </tbody> </table> <p>این نوع از تجزیه‌گرهای بالا به پایین، تجزیه‌گرهای شیفیتی-کاهشی «shift-reduce» هم نامیده می‌شوند. چون ورودی به سمت راست شیفت داده می‌شود (تصور کنید که اشاره‌گر ابتدا به اولین مقدار ورودی اشاره می‌کند و بعد به سمت راست حرکت می‌کند) و به تدریج قواعد نحوی را تولید می‌کند.</p> <h4 id=generating-parsers-automatically>ایجاد خودکار تجزیه‌گرها</h4> <p>ابزارهای وجود دارند که می‌توانند به طور خودکار یک تجزیه‌گر تولید کنند. به این صورت که شما به آنها گرامر زبان خود را می‌خورانید-گرامری که شامل دایره واژگان و قواعد دستوری است- و آن‌ها برای شما یک تجزیه‌گر واقعی ایجاد می‌کنند. ساختن یک تجزیه‌گر نیازمند درک بالایی از تجزیه‌گرهاست که در نوع خودش ساختن یکی از آنها با دست خالی که بهینه نیز باشد،کار چندان ساده‌ای نیست. به همین دلیل ایجاد کننده‌‌های خودکار تجزیه‌گرها ابزاری بسیار مفیدی در نوع خود به شمار می‌آیند.</p> <p>وب‌کیت از دو ایجاد کننده‌ی خودکار تجزیه‌گرها استفاده می‌کند که عبارتند از: <strong>فِلِگس</strong> «<a href=http://en.wikipedia.org/wiki/Flex_lexical_analyser>Flex</a>» برای ساختن لِگزر و <strong>بایسِن</strong> «<a href="http://www.gnu.org/software/bison/">Bison</a>» برای ساختن یک تجزیه‌گر (که شاید اسم آنها تحت عنوان Lex و Yacc به گوشتان خورده باشد). ورودی فلگس فایلی است که متشکل شده از عبارات باقاعده‌ای که تُکن‌های معتبر را تعریف کرده است؛ و ورودی بایسن هم تشکیل شده از قواعد دستوری زبان که به فرمت <abbr title="Backus Naur Form">BNF</abbr> در آمده‌اند.</p> <h3 id=html-parser>تجزیه‌گر HTML</h3> <p>کار این تجزیه‌گر این است که دستورات HTML را به درخت تجزیه تبدیل کند.</p> <h4 id=the-html-grammar-definition>گرامر تعریف شده‌ی زبان HTML</h4> <p>واژگان و قواعد دستوری زبان HTML توسط سازمان W3C در <a href=http://www.w3.org/TR/html5/syntax.html>مستندات</a> کامل این زبان آورده شده است.</p> <h4 id=not-a-context-free-grammar>چرا گرامر HTML بدون چارچوب است؟!</h4> <p>همان طور که در معرفی تجزیه‌گرها دیدیم، قواعد گرامری می‌توانند به شکلی تعریف شوند که از فرمت‌های نظیر <abbr title="Backus Naur Form">BNF</abbr> استفاده کنند. متاسفانه هیچ یک از تجزیه‌گرهای معمول بحث شده در فصل قبلی را نمی‌توانیم برای تجزیه‌ی HTML‌ استفاده کنیم (من فصل قبل را صرفاً برای سرگرمی نیاوردم-از آن مفاهیم در فصل‌های بعدی در شرح تجزیه‌گرهای CSS و جاوااسکریپت استفاده خواهیم کرد). گرامر مورد نیاز تجزیه‌گرها برای HTML را نمی‌توان به راحتی توسط گرامرهای بدون چارچوب تعریف کرد.</p> <p>یک فرمت مشخص برای تعریف گرامر HTML‌ به نام «Document Type Definition» وجود دارد که به اختصار به آن <abbr title="Document Type Definition">DTD</abbr> می‌گویند. اما <abbr title="Document Type Definition">DTD</abbr> نیز یک گرامر با چارچوب آزاد نیست. قبول دارم که این موضوع شاید در نگاه اول کمی عجیب به نظر برسد؛ زیرا HTML چیزی شبیه به <abbr title="Extensible Markup Language">XML</abbr>‌ است. و خب تجزیه‌گرهای زیادی برای <abbr title="Extensible Markup Language">XML</abbr>‌ وجود دارد. حتی یک نوع خاصی هم از HTML وجود دارد که به آن <abbr title="Extensible Hypertext Markup Language:">XHTML</abbr> می‌گویند! پس تفاوت در چیست؟</p> <p>تفاوت در این است که HTML زیادی <strong>بخشنده</strong> «forgiving» است! به طوری که او به شما خورده‌ای نمی‌گیرد اگه حواستان نباشد و یکی از تگ‌های اصلی را جا بیندازید (مانند head)، یا یادتان برود تگی را ببندید یا باز کنید و به همین منوال. به عبارتی HTML‌ دارای یه قاعده دستوری نرم و منعطف است، برخلاف آن چیزی که در <abbr title="Extensible Markup Language">XML</abbr>‌ اتفاق می‌افتد.</p> <p>همین اختلاف به ظاهر جزیی، باعث یک دنیا اختلاف شده است. از سوی دیگر، همین تفاوت است که باعث محبوبیت HTML شده است. او اشتباهات شما را نادیده می‌گیرد و زندگی را برایتان شیرین! و البته از سوی دیگر نوشتن یک گرامر مشخص را بسیار سخت می‌گرداند.</p> <h4 id=html-dtd>HTML <abbr title="Document Type Definition">DTD</abbr></h4> <p>گرامر HTML در قالب <abbr title="Document Type Definition">DTD</abbr> تعریف می‌شود. این قالب برای تعریف زبان‌های خانواده‌ی <a href=http://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language><abbr title="Standard Generalized Markup Language">SGML</abbr></a> استفاده می‌شود؛ و شامل تعاریف تمامی عناصر مجاز به همراه خصوصیات و فرزندانشان است.</p> <h4 id=dom>DOM</h4> <p>خروجی درخت تجزیه، درختی است به نام درخت عناصر DOM و خصوصیات این عناصر. DOM‌ اختصار شده‌ی Document Object Model است. این شی بیان کننده‌ی و نمایش‌دهنده‌ی سند HTML و رابط عناصر آن با دنیای بیرون مانند جاوااسکریپت است. به بیان دیگر، با این شی است که سند HTML و عناصر آن معنی می‌یابند و می‌توانند با لایه‌های دیگر ارتباط برقرار کنند.</p> <p>ریشه‌ی درخت DOM، شی «Document» است. که تمامی اجزای دیگر از آن ریشه گرفته‌اند. DOM یک رابطه یک-به-یک با دستورات HTML دارد. برای مثال:</p> </div> <div class="code-wrapper mb-base"> <div class=container> <pre><code class=language-html>&lt;html&gt;
  &lt;body&gt;
     &lt;p&gt;Hello World&lt;/p&gt;
     &lt;div&gt;&lt;img src=&quot;example.png&quot;/&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre> </div> </div> <div class=container> <p>قطعه کد وقتی به درخت DOM‌ تبدیل شود، به شکل زیر در می‌آید:</p> <figure class="lazy text-center"> <img src=/assets/images/placeholder.png data-layzr=/assets/images/content/2015/12/dom-tree-of-html-markup.png alt="درخت DOM تشکیل شده از مارک‌آپ مثال قبلی"> <figcaption>درخت DOM تشکیل شده از قطعه کد بالا</figcaption> </figure> <h4 id=the-parsing-algorithm>الگوریتم تجزیه HTML</h4> <p>همان‌طور که در بخش قبلی دیدیم، بنا به این دلایل، HTML‌ را نمی‌توان با تجزیه‌گرهای معمول بالا به پایین یا پایین به بالا تجزیه کرد:</p> <ol> <li>ذات سخاوتمند HTML.</li> <li>این حقیقت که مرورگرها برای مواجه و پشتیبانی از موارد شناخته شده از دستورات نامعتبر HTML دارای یک مکانیزم سنتی چشم‌ پوشی از خطا هستند.</li> <li>فرآیند تجزیه‌ HTML‌ متاثر از منابع مختلف است؛ در صورتی که در زبان‌های دیگر منبع در طول مدت تجزیه و تبدیل محفوظ و بدون تغییر می‌ماند. این در حالی است که HTML با دارا بودن کدی پویا، که هر لحظه ‌می‌تواند تحت تاثیر یک عنصر بیرونی (مانند یک تگ script‌ که شامل چنین فراخوانی باشد: <code>()document.write</code>) قرار بگیرد و با اضافه شدن یک تُکن خارجی، باعث شود تا کل نتیجه‌ی خروجی تغییر کند.</li> </ol> <p>ناتوانی در استفاده از تجزیه‌گرهای معمول، باعث آن شده است که مرورگرها خودشان دست به کار شوند و دست به ساختن تجزیه‌گرهای HTML مختص به خودشان بزنند. <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html>نمونه‌ای از این الگوریتم‌های تجزیه‌گر با جزییات در مستندات HTML5 توضیح داده شده است</a>.</p> <p>این الگوریتم از دو بخش تشکیل شده است: علامت گذاری «tokenization» و ساخت درخت «tree construction».</p> <figure class="lazy text-center"> <img src=/assets/images/placeholder.png data-layzr=/assets/images/content/2015/12/html-parsing-flowchart.png alt="نمودار چرخه‌ی تجزیه‌ی HTML"> <figcaption>نمودار چرخه‌ی تجزیه‌ی HTML</figcaption> </figure> <p>علامت گذاری همان بررسی لِگزیکال‌ها است؛ تجزیه ورودی‌ها به تُکن‌ها. از جمله‌ی تُکن‌های HTML می‌توان به تگ‌های شروع و پایان، خصوصیت‌ها «attributes» و مقادیر این خصوصیت‌ها اشاره کرد.</p> <p>علامت‌گذار، تُکنی را شناسایی می‌کند و بعد آن را به سازنده‌ی درخت می‌دهد. این چرخه تا جای تکرار می‌شود که تمامی ورودی‌ها علامت‌گذاری و در درخت جانمایی شده باشند. نمودار جریان زیر نشان دهنده‌ی همین چرخه‌ است.</p> <figure class="lazy text-center"> <img src=/assets/images/placeholder.png data-layzr=/assets/images/content/2015/12/html-parsing-flow.png alt="چرخه‌ی تجزیه‌ی HTML"> <figcaption>چرخه‌ی تجزیه‌ی HTML</figcaption> </figure> <p class=notice-quote>حذف شده: <a href=http://taligarsiel.com/Projects/howbrowserswork1.htm#The_parsing_algorithm>شرح الگوریتم علامت گذاری</a> - <a href=http://taligarsiel.com/Projects/howbrowserswork1.htm#Tree_construction_algorithm>شرح الگوریتم ایجاد کننده‌ی درخت DOM</a></p> <h4 id=actions-when-the-parsing-is-finished>چه اتفاق‌هایی بعد از اتمام تجزیه HTML رخ می‌دهد؟</h4> <p>در این مرحله مرورگر شی document را به عنوان شی قابل تعامل نشانه‌گذاری می‌کند (این دقیقا همان لحظه است که رخداد <a href=https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded>DOMContentLoaded</a> توسط مرورگر فراخوانی می‌شود) و اسکریپت‌های که به صورت «deferred» نشان‌گذاری شده‌اند اجازه‌ی اجرا پیدا می‌کنند (اسکریپت‌های که دارای این خصوصیت هستند، ملزم هستند تا انتهای تجزیه سند منتظر بمانند و سپس اجرا شوند. یعنی اجازه ندارند جلوی اجرای تجزیه‌گر و لود DOM را بگیرند). بعد از اجرای این اسکریپت‌ها حالت سند به «complete» تغییر کرده و مطابق آن رخداد «<a href=https://developer.mozilla.org/en-US/docs/Web/Events/load>load</a>» فراخوانی می‌شود.</p> <h4 id=browsers-error-tolerance>چرا مرورگرها از خطاهای HTML‌ می‌گذرند؟!</h4> <p>از مرام مرورگرها به دور است که هنگام دیدن یک خطای دستوری «Invaild Syntax» هنگام اجرای یک سند HTML آن را بروز دهند چه برسد به اینکه بخواند جلوی اجرای آن را بگیرند. بلکه با نهایت تواضع و احترام، بیشتر خطاهای موجود را خود برطرف می‌کنند و به کارشان ادامه می‌دهند؛ بدون اینکه مزاحم شما شوند، گویی آب از آب تکان نخورده است! تمامی این فداکاری‌ها، فقط و فقط به خاطر کاربر نهایی و تجربه‌ی است که او قرار است در هنگام مرور یک صفحه‌ی وب داشته باشد!</p> <p>به عنوان مثال این کد HTML‌ را در نظر بگیرید:</p> </div> <div class="code-wrapper mb-base"> <div class=container> <pre><code class=language-html>&lt;html&gt;
  &lt;mytag&gt;&lt;/mytag&gt;
  &lt;div&gt;
    &lt;p&gt;
  &lt;/div&gt;
      Really lousy HTML
  &lt;/p&gt;
&lt;/html&gt;</code></pre> </div> </div> <div class=container> <p>در کد بالا من از چند قاعده تخطی کرده‌ام («mytag» یک تگ استاندارد نیست، رعایت نکردن تقدم سطوح در تگ‌های «div» و «p» و موارد دیگر) ولی با این حال مرورگر هم‌چنان شکایتی ندارد و حتی به صورت درست سند را نمایش می‌دهد!</p> <p>مدیریت خطاها یکی از اصول ثابت و اولیه در مرورگرها است، این در حالی است که هیچ کدام از این قواعد در کمال تعجب جز خصوصیات ذاتی تدوین شده‌ی برای HTML نیست! مانند بوکمارک کردن و دکمه‌های عقب و جلو،‌ این قابلیت نیز سال‌های متمادی که به صورت پیش‌فرض و به عنوان یک سری قوانین نانوشته توسط توسعه دهندگان مرورگرها پشتیبانی می‌شود. البته HTML5 تعدادی از این پیش‌نیاز‌ها را برای مدیریت خطاهای نحوی در مستندات خویش آورده است.</p> <h3 id=css-parsing>تجزیه CSS</h3> <p>مفاهیم گفته شده درباره‌ی تجزیه‌ی داده‌ها ورودی را که گفته شد یادتان هست؟ خب، برخلاف HTML، گرامر زبان CSS جزء گرامرهای بدون چارچوب محسوب ‌می‌شود و به وسیله‌ی همان نوع تجزیه‌گرهای که برایتان شرح داده شد، قابل تجزیه است. در حقیقت <a href=http://www.w3.org/TR/CSS2/grammar.html>قواعد دستوری و واژگان CSS</a> به طور مشخص و ثابت در مستندات آن آورده شده است. حالا اگر علاقه‌مند بودید که بفهمید دقیقا رفتار این تجزیه‌گر چگونه است و چطور دستورات را تجزیه می‌کند؛ می‌توانید به <a href=http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#CSS_parsing>این‌ مدخل</a> مراجعه کنید.</p> <h4 id=webkit-css-parser>تجزیه‌گر CSS موتور وب‌کیت</h4> <p>دیدیم که وب‌کیت از دو ایجاد کننده‌ی خودکار تجزیه‌گر به نام‌های فلیگس و بایسون استفاده می‌کند؛ که برای برای ساختن خودکار تجزیه‌گر CSS، تنها کافی است که فایل‌های گرامر زبان CSS را به آنها بخوراند. اگر به یاد داشته باشید، گفتیم که بایسون یک پارسر پایین به بالایِ شیفتیِ-کاهنده می‌سازد؛ اما در مقابل فایرفاکس از یک پارسر بالا به پایین که خودش درست کرده است استفاده می‌کند. در هر دو مورد، فایل CSS به یک شی StyleSheet تجزیه و تبدیل می‌شود. هر کدام از اشیا در بر گیرنده‌ی قواعد CSS هستند. این اشیایِ قواعد CSS علاوه‌ بر اینکه شامل اشیایِ انتخابگرها «selector» و خصوصیاتشان «declaration» هستند، شامل دیگر اشیای مرتبطشان در گرامر CSS نیز می‌شوند. شکل زیر به طور کامل گویای این است که ما به چه چیزی یک شی StyleSheet‌ می‌گوییم و آن دربردارنده‌ی چه اشیایی است.</p> <figure class="lazy text-center"> <img src=/assets/images/placeholder.png data-layzr=/assets/images/content/2015/12/parsing-css-style-tree.png alt="درخت حاصل از تجزیه‌ی CSS"> <figcaption>درخت حاصل از تجزیه‌ی CSS</figcaption> </figure> <h3 id=the-order-of-processing-scripts-and-style-sheets>ترتیب پردازش اسکریپت‌ها و برگه‌های استایل</h3> <h4 id=scripts>اسکریپت‌ها</h4> <p class=notice-quote>نکته: زین پس ما به جای synchronous خواهیم گفت: <strong>ترتیبی</strong> و به جای asynchronous می‌گوییم: <strong>موازی</strong></p> <p>فرآیند کلی پردازش در وب، به صورت ترتیبی و پشت سر هم است. توسعه دهندگان انتظار دارند که اسکریپت‌ها به محض اینکه تجزیه‌گر به تگ آغازین <code>&lt;script&gt;</code> می‌رسد، تجزیه و اجرا شوند. به همین دلیل تجزیه‌گر HTML تا زمانی که اجرای اسکریپت به پایان برسد، متوقف خواهد ماند. در صورتی هم که اسکریپت از نوع خارجی باشد که به یک فایل بیرونی ارجاع داده شده باشد، تجزیه‌گر باید صبر کند تا داده‌های اسکریپت از طریق لایه‌ی شبکه دریافت و تحویل داده شود تا بعد از تجزیه و اجرای اسکریپت، تجزیه‌گر اصلی HTML دوباره کارش را بتواند ادامه دهد. که خود این عمل دریافت داده‌ها از لایه شبکه هم پردازشش به صورت ترتیبی خواهد بود. این مدل از فرآیند پردازشی برای سالیان متمادی است که وجود دارد و در مستندات نسخه‌های ۴ و ۵ HTML شرحش هم آمده است.</p> <p>توسعه دهندگان در مواجه با این مشکل، آنقدرها هم بی‌چاره نیستند و می‌توانند با اضافه کردن خصوصیت «defer» به تگ script از متوقف شدن تجزیه‌گر HTML جلوگیری کنند و اجرای اسکریپت را به بعد از پایان یافتن کامل فرآیند دریافت و تجزیه‌ی HTML موکول کنند. ولی با این حال آن مشکل دریافت داده‌های اسکریپت‌های خارجی به صورت یک فرآیند ترتیبی همچنان به قوت خود باقی بود که با آمدن HTML5 و اضافه شدن خصوصیت «async» این مشکل هم تا حدودی مرتفع شد. اسکریپت‌های که دارای این خصوصیت باشند، توسط مرورگر در یک جریان «thread» جداگانه‌ای به صورت موازی با جریان‌های پردازشی دیگر دریافت و تجزیه می‌شوند. با این حال هنوز مرورگرهای مدرن هم برای انجام فرآیندهای موازی نیز با محدودیت مواجه هستند. به طوری که تنها می‌توانند در لایه‌ی شبکه به ۲ الی ۶ درخواست همزمان به صورت موازی رسیدگی کنند. (این ویژگی فقط مختص منابع خارجی مانند فایل‌های CSS، تصاویر، اسکریپت‌ها و قلم‌ها است.)</p> <h4 id=style-sheets>برگه‌های استایل «stylesheet»</h4> <p>از سوی دیگر برای پردازش برگه‌های استایل نسبت به اسکریپت‌ها از مدل پردازشی دیگر استفاده می‌شود. شاید بگویید که، از آنجایی که استایل شیت‌ها نمی‌توانند تغییری در درخت DOM بدهند، دلیلی ندارد که منتظر آنها بمانیم و اجازه بدهیم که کار تجزیه HTML را مختل کنند و جلوی آن را بگیرند! بله از نظر مفهومی حق با شماست، ولی اینجا یک مشکل داریم؛ آن هم این است که در زمانی که فرآیند اصلی تجزیه‌ی HTML در حال اجرا است، اسکریپتی اطلاعاتی از یکی از برگه‌های استایل لازم داشته باشد. اگر اطلاعات استایلی خواسته شده هنوز دریافت و تجزیه نشده باشند، در خوش بینانه‌ترین حالت اگه فرآیند اجرای اسکریپت متوقف نشود، باید انتظار یک دادن یک جواب نادرست را داشته باشیم.</p> <p>این مسئله شاید به نظر یک مورد خاصی به نظر برسد که احتمال وقوع آن خیلی نادر باشد، ولی تجربه نشان داده که برعکس، خیلی هم رایج است. برای جلوگیری از وقوع همچین مشکلاتی، فایرفاکس تر و خشک را باهم می‌سوزاند. یعنی تا زمانی که تمامی برگه‌های استایل صفحه دریافت و تجزیه نشده باشند، اجرای تمامی اسکریپت‌ها را متوقف می‌کند؛ حتی آن‌هایی که کاری به کار استایل نداشته باشند. اما وب‌کیت با انصاف‌تر عمل می‌کند و تنها جلوی اجرای اسکریپت‌هایی را می‌گیرد که نیاز به اطلاعات برگه‌های استایلی داشته باشند که هنوز بارگذاری نشده‌اند.</p> <h4 id=speculative-parsing>تجزیه‌‌‌ی موازی</h4> <p>هر دوی موتورهای وب‌کیت و گِکو عمل تجزیه موازی را به صورت بهینه‌ای انجام می‌دهند. وقتی که اسکریپتی در حال اجرا است، جریان‌های دیگر، کار تجزیه‌ی و ترجمه مابقی HTML‌ را ادامه می‌دهند؛ تا بفهمند که چه منابعی باید از لایه شبکه دریافت و بارگذاری شوند؛ تا برای بارگذاریشان اقدام کنند. در این روش، منابع می‌توانند به صورت خطوط ارتباطی موازی از هم دریافت و بارگذاری شوند که حاصل این کار باعث کاهش زمان بارگذاری کل صفحه می‌شود. به همین دلیل به این روش تجزیه‌ی موازی می‌گویند.</p> <p>البته توجه داشته باشید که این موضوع تجزیه‌گرهای موازی، تنها به تجزیه‌گرهایی مربوط می‌شود که به منابع خارجی مانند اسکریپت‌ها، برگه‌های استایل، تصاویر و فونت‌های اشاره دارند که درخت DOM را تغییر نمی‌دهند! - یعنی تجزیه‌گر اصلی HTML بدون توجه به فرآیند دریافت و بارگذاری آن‌ها می‌توانند کار خودش را انجام دهد؛ و کاری به کار هم نداشته باشند و هر کدام به طور مستقل بتوانند کارشان را به پایان ببرند.</p> <h3 id=render-tree-construction>ساخت درخت رندر</h3> <p>زمانی که درخت DOM تکمیل شد، مرورگر شروع به ایجاد درختی دیگر، به نام درخت رندر می‌کند. گره‌های تشکیل دهنده‌ی این درخت، عناصر گرافیکی صفحه هستند. این عناصر درست به همان ترتیبی که در صفحه نمایش باید ظاهر شوند، از بالا به پایین بر روی درخت رندر جاگذاری می‌شوند. هدف از تشکیل این درخت، آسان کردن لایه‌ی رنگرزی است که با کمترین دردسر بتواند با ترتیب درست به نقاشی عناصر تشکیل دهنده‌ی صفحه بپردازد.</p> <p>فایرفاکس به این عناصر گرافیکی و به نوعی گره‌های درخت رندر، «فریم» می‌گوید. در حالی که وب‌کیت از لفظ «رندر شده‌ها» یا «اشیای رندر» برای آن‌ها استفاده می‌کند.</p> <p>یک شی رندر می‌داند که چطور خود و بچه‌هایش را رنگرزی و صفحه بندی (لایه بندی؛ اینکه جایگاهش در صفحه، از نظر طول و عرض دقیقا کجای صفحه است) بکند.</p> <p>کلاس <code>RenderObject</code> وب‌کیت که کدش را در قسمت زیر مشاهده می‌کنید، کلاس پایه‌ی همین اشیای رندر یا فریم‌ها هستند:</p> </div> <div class="code-wrapper mb-base"> <div class=container> <pre><code class=language-javascript>class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;  // the DOM node
  RenderStyle* style;  // the computed style
  RenderLayer* containgLayer; // the containing z-index layer
}</code></pre> </div> </div> <div class=container> <p>هر شی رندر دارای یک ناحیه‌ی مستطیلی شکل فرضی است که نشان دهنده‌ی همان CSS box معروف است که در CSS2 اضافه شده است (برای دیدن این مستطیل در مرورگر خود کافی است خاصیت <code>outline</code> عنصر مورد نظرتان را با <code>1px solid red</code> مقدار دهی کنید). این ناحیه همان طور که گفته شد مشخص کننده‌ی محدوده‌ی عنصر بر روی صفحه نمایش است که نمود اطلاعات هندسی عنصر مانند طول و عرض و موقعیت عنصر در صفحه است.</p> <p>نوع این ناحیه نیز متاثر از مقدار خصوصیت <code>display</code> استایل عنصر مورد نظر است که مطابق است با گره‌ی متناظرش. در قطعه کد زیر که از موتور وب‌کیت استخراج شده، موتور بر اساس آن تصمیم می‌گیرد که چه نوع شی رندری باید برای گره‌ی متناظر در درخت DOM بر اساس خصوصیت <code>display</code> آن ساخته شود:</p> </div> <div class="code-wrapper mb-base"> <div class=container> <pre><code class=language-javascript>RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
    Document* doc = node-&gt;document();
    RenderArena* arena = doc-&gt;renderArena();
    ...
    RenderObject* o = 0;
    switch (style-&gt;display()) {
        case NONE:
            break;
        case INLINE:
            o = new (arena) RenderInline(node);
            break;
        case BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case INLINE_BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case LIST_ITEM:
            o = new (arena) RenderListItem(node);
            break;
       ...
    }
    return o;
}</code></pre> </div> </div> <div class=container> <h3 id=the-render-tree-relation-to-the-dom-tree>رابطه درخت رندر با درخت DOM</h3> <p>اشیای رندر یا همان فریم‌ها با گره‌های درخت DOM در ارتباط هستند؛ ولی رابطه‌ی آن از نوع یک-به-یک نیست. عناصر غیر-گرافیکی DOM (همان‌های که در صفحه نمایش داده نمی‌شوند و مقدار <code>display</code> آنها برابر با <code>none</code> است) در درخت رندر آورده نمی‌شوند. مانند تگ “head” که همیشه مخفی است (مقدار خصوصیت <code>display</code> تگ “head” به صورت پیش فرض برابر با <code>none</code> است). اما این برای عناصر که خصوصیت <code>visibility</code> آن‌ها برابر با <code>hidden</code> است، صدق نمی‌کند و این عناصر در درخت رندر آورده می‌شوند.</p> <p>عناصری از DOM هستند که به طور همزمان با چند عنصر گرافیکی در ارتباط هستند. این عناصر معمولا دارای ساختار پیچیده‌ای هستند که نمی‌شود آنها را تنها با یک ناحیه‌ی مستطیلی تنها توصیف کرد. مانند عنصر “select” که خود به ۳ شی رندر مرتبط است؛ که عبارتند از: یکی برای ناحیه نمایشی (مستطیل اصلی)، یکی برای لیست باز شونده (همان “drop down”) و یکی نیز برای دکمه. و البته وقتی که متن هر یک از موارد لیست یا دکمه به خاطر نامناسب بودن عرض تعیین شده برایش به چند خط بشکند، برای هر خط، درخت رندر یک شی رندر در نظر می‌گیرد.</p> <p>مثالی دیگر از این عناصر چند شی ای می‌توان به استفاده‌ی نابجای عناصر HTML اشاره کرد. طبق مستندات CSS یک عنصر <code>inline</code> یا باید در بر گیرنده‌ی فقط یک عنصر از نوع <code>block</code> باشد یا فقط از نوع <code>inline</code>. در صورتی که از ترکیب این دو نوع باهم در درون آن استفاده شود باعث ایجاد یک شی <code>block</code> بی نام و نشان می‌شود که عناصر <code>inline</code> را در بر گرفته است (به اصطلاح آنها را “wrap” می‌کند).</p> <p>بعضی از اشیای رندر «فریم» هم هستند که به یک گره از DOM مرتبط شده‌اند؛ ولی نه به همان ترتیبی که در درخت رندر قرار گرفته‌اند. عناصر <code>float</code> و <code>absolute</code>-ی که خارج از جریان کلی صفحه موقعیت دهی شده باشند؛ در جای دیگری، از آنجایی که در درخت رندر برایشان تعریف شده است، جانمایی می‌شوند.</p> <figure class="lazy text-center"> <img src=/assets/images/placeholder.png data-layzr=/assets/images/content/2015/12/the-render-tree-and-the-corresponding-dom-tree.png alt=the-render-tree-and-the-corresponding-dom-tree> <figcaption>درخت رند و درخت DOM متناظر با آن. <code>Viewport</code> یک بلاک در برگیرنده‌ای اولیه است که به صورت پیش فرض فراخوانی می‌شود. در وب‌کیت به عنوان یک شی <code>RenderView</code> شناخته می‌شود.</figcaption> </figure> <h4 id=the-flow-of-constructing-the-tree>فرآیند ساخت درخت رندر</h4> <p>در فایرفاکس، ایجاد کننده درخت رندر به عنوان یک منتظر «listerner» برای آپدیت‌های DOM عمل می‌کند. به طوری که او عمل ساختن فریم را به متد اصلی سازنده فریم <code>FrameConstructor</code> محول «delegate» می‌کند و این متد سازنده است که استایل‌ها را محاسبه می‌کند (<a href=#style-computation>ببینید بخش محاسبه استایل را</a>) و فریم را تشکیل می‌دهد.</p> <p>در وب‌کیت، فرآیند محاسبه استایل و تشکیل شی‌های رندر، <strong>ضمیمه</strong> «attachment» نامیده می‌شود. هر گره‌ی درخت DOM، یک متد <code>attach</code> دارد. فرآیند اجرای ضمیمه هم به صورت ترتیبی است؛ به این صورت که وقتی گره‌ای به درخت DOM اضافه می‌شود، متد <code>attach</code> گره‌ی تازه از راه رسیده فراخوانی می‌شود.</p> <p>به موجب پردازش دو تگ <code>html</code> و <code>body</code> صفحه‌‌ی HTML گره‌ی ریشه‌ی درخت رندر ساخته می‌شود. شی ریشه‌ی درخت رندر طبق آن چیزی که در مستندات رسمی CSS آمده است، یک بلوک در برگیرنده با این تعریف است: بلوکی با بالاترین سطح، که در برگیرنده‌ی تمامی بلوک‌های موجود در صفحه است. از طرفی هم این همان بلوکی است که به شی «viewport» ابعاد می‌دهد (منظور همان ابعاد ناحیه‌ای است که پنجره نمایش مرورگر در صفحه نمایشگر اشغال کرده است). فایرفاکس این بلوک را <code>ViewPortFrame</code> می‌خواند و وب‌کیت نیز آن را <code>RenderView</code>. این شی دقیقا همان شی است که گره‌ی <code>document</code> از درخت DOM به آن اشاره می‌کند. مابقی درخت رندر هم با جانمایی گره‌های بعدی درخت DOM در گره‌های متناظرشان در درخت رندر به عنوان فرزندان شی <code>RenderView</code> ساخته می‌شود.</p> <h4 id=style-computation>محاسبه‌ی استایل</h4> <p>لازمه‌ی ساختن درخت رندر، محاسبه‌ی خصوصیات گرافیکی هر کدام از اشیای آن است؛ که این امر از طریق محاسبه‌ی تک تک خصوصیات استایلی مربوط به هر عنصر صفحه قابل حصول است.</p> <p>وقتی می‌گوییم استایل، منظورمان کلیه‌ی صفحه‌هات استایلی است که از مبادی مختلف گرد آوری شده‌اند. این مبادی عبارتند از:‌ استایل‌های درونی عناصر «inline» (منظور هم آنهایی است که به صورت خصوصیت <code>style</code> برای یک تگ تعریف می‌شوند و هم آنهایی که در داخل تگ <code>&lt;style&gt;</code> قرار می‌گیرند.)، خصوصیت‌های گرافیکی HTML (مانند <code>bgcolor</code>)، فایل‌های CSS بیرونی و در نهایت استایل پیش‌فرضی که خود مرورگر تعریف کرده است که به آنها «مصدر» “origin” می‌گویند.</p> <p>اصلا چرا می‌گوییم «<strong>محاسبه‌ی</strong>» استایل‌ها؟! نمی‌گوییم مثلا اضافه کردن استایل‌ها. به خاطر این‌که همان طور که در بند قبلی به آن اشاره شد، استایل‌های یک عنصر از مبادی متعددی قابل حصول هستند که هر یک نسبت به دیگری اولویت خاصی دارد و از طرفی نحوه‌ی تعریف کردن قواعد استایل‌ها در صفحه‌هات استایلی نیز دارای ترتیب و نظم خاصی است که سطوحی از اولویت‌های مختلف را شامل می‌شوند؛ که همه‌ی این‌ها نیازمند یک سری محاسباتی ریاضی است تا ترتیب صحیح نحوه‌ی اِعمال این استایل‌ها مشخص شود. به دلیل این پیچیدگی‌ها، محاسبات استایل‌ها برای مرورگرها با مشکلات و سختی‌هایی همراه است که آنها عبارتند از:</p> <ol> <li>داده‌های استایلی یک سازه‌ی عظیمی از ساختمان داده‌ها را ایجاد می‌کند که نگهداری این حجم عظیم از خصوصیات، بعضا در سایت‌های بزرگ باعث بروز مشکلات مربوط به کمبود حافظه (از نوع رَم) می‌شود.</li> <li>پیدا کردن قواعد استایلی مربوط به هر عنصر در صورتی که بهینه نباشند، باعث بروز مشکلاتی در کارایی (منظور همان پرفورمنس است) بارگذاری صفحه می‌شود. پیمایش لیست کامل قواعد استایلی برای پیدا کردن عناصر مورد نظر، بار پردازشی سنگینی بر دوش مرورگر می‌گذارد. انتخابگرها «selector» می‌توانند از ساختار پیچیده‌ای تشکیل داشته باشند که موجب شود در فرایند پردازش تعیین مسیر درست بر روی درخت DOM به مسیرهایی بر بخوریم که در ابتدا به نظر امید بخش و قابل حصول می‌رسند، ولی در آخر معلوم شود که مسیر اشتباهی بوده و همین طور برعکس. برای مثال بیاید انتخابگر زیر بررسی کنیم:</li> </ol> </div> <div class="code-wrapper mb-base"> <div class=container> <pre><code class=language-css>div div div div {
  ...
}</code></pre> </div> </div> <div class=container> <p>انتخابگر بالا به این معنی است که قواعد مورد نظر باید به یک تگ «div» که خودش زیر مجموعه‌ی سه تگ «div» است، اعمال شود. از آنجایی که انتخابگر‌ها از راست به چپ خوانده می‌شوند، ما در پایین‌ترین سطح درخت، یعنی برگ‌ها، تمامی گره‌های «div» را مشخص می‌کنیم و بعد آنهایی را نگهداریم که در گره‌های والدش یک تگ «div» باشد؛ و این کار را تا جایی به سمت بالا ادامه می‌دهیم که تمام مسیر‌هایی که روی درخت مطابق با قاعده‌ی انتخابگر ما است، حاصل شود. حالا مشکل جایی بروز می‌کند که ما مسیری را ممکن است طی کنیم که نهایتا به دو تگ تو در توی «div» یا ۳ تگ تو در تو می‌انجامد که خب، هیچ کدامشان قابل قبول نیستند. همین رفتن و برگشتن‌های بی‌حاصل مرورگر، وقتی تعداد انتخابگر‌های یک سایت بیش تر از چند صد تا باشد، باعث کاهش کارایی آن خواهد شد. 3. پیچیدگی اعمال قواعد یا همان خصوصیات گرافیکی عناصر با در نظر گرفتن ترتیب و اولیت‌های تعریف شده برای قواعد.</p> <p>خوش بختانه مرورگرها نرم‌افزارهای پرتلاشی هستند و سعی کرده‌اند تا به <a href=http://taligarsiel.com/Projects/howbrowserswork1.htm#Sharing_style_data>روش‌های</a> <a href=http://taligarsiel.com/Projects/howbrowserswork1.htm#Firefox_rule_tree>مختلف</a> و با بهره بردن از <a href=http://taligarsiel.com/Projects/howbrowserswork1.htm#Manipulating_the_rules_for_an_easy_match>الگوریتم‌های</a> <a href=http://taligarsiel.com/Projects/howbrowserswork1.htm#Applying_the_rules_in_the_correct_cascade_order>بهینه</a> تا آنجایی که امکان دارد بر این مشکلات فایق آیند؛ ولی شکی نیست که توسعه‌دهندگان باید به روش‌های ناصحیح و صحیح توسعه‌ی CSS تسلط کامل داشته باشند تا بتوانند تا آنجایی که می‌توانند کار را برای مرورگر‌ها آسان‌تر کنند؛ که در نهایت به کمک هم بتوانند یک تجربه‌ی فوق العاده برای کاربر رقم بزنند.</p> <h4 id=css-gradual-process>فرآیند تدریجی و گام به گام تجزیه‌ی CSS</h4> <p>وب‌کیت از یک پرچم «flag» برای نشان‌دار کردن تمامی صفحات استایلی (حتی <code>imports@</code>) که به صورت کامل بارگذاری شده است، استفاده می‌کند. اگر استایلی هنگام عملیات ضمیه کردن «attaching» به طور کامل بارگذاری نشده باشد، استایل پیش فرض اعمال می‌شود و وقتی که استایل بارگذاری شد، دوباره محاسبات مربوط به آن عنصر انجام می‌گیرد.</p> <h2 id=layout>صفحه بندی «layout»</h2> <p>وقتی که اشیای رندر ایجاد شدند و به درخت رندر اضافه می‌شوند، هنوز اندازه «size» و موقیعتشان «position» در صفحه مشخص نشده است. محاسبه این مقادیر بر عهده‌ی قسمت صفحه بندی یا <strong>باز جانمایی</strong> «reflow» است.</p> <p>سند HTML از یک مدلی شبیه حرکت جریان رود «flow» برای صفحه بندی استفاده می‌کند. بدان معنی که بیشتر اوقات ممکن است که محاسبات هندسی تنها در یک جهت صورت بگیرد (اشاره به جریان آب رودخانه دارد که تنها به یک سو و جهت شناور است). عناصری که بعداً به جریان صفحه اضافه ‌می‌شوند، عناصری که از قبل در جریان بوده‌اند را از لحاظ مقادیر هندسی‌شان، تحت تاثیر قرار نمی‌دهند. به همین دلیل از آنجایی که جهت متون در HTML به خاطر زبان انگلیسی به طور پیش فرض چپ به راست در نظر گرفته شده است، این جریان صفحه بندی عناصر صفحه نیز تحت تاثیر آن به طور پیش فرض به صورت «چپ به راست» و از «بالا به پایین» است.</p> <figure class="lazy text-center"> <img src=/assets/images/placeholder.png data-layzr=/assets/images/content/2015/12/layout-rect-calculate-the-position-size.jpg alt=layout-rect-calculate-the-position-size> <figcaption>مثالی از نحوه‌ی محاسبه مختصات یک پاراگراف و صفحه بندی آن</figcaption> </figure> <p>سیستم مختصات دهی عناصر صفحه، وابسته به فریم ریشه است؛ که به طور پیش فرض مبدا آن در گوشه‌ی بالایی سمت چپ صفحه مرورگر است در زبان‌های چپ به راست. این نقطه با مختصات 0,0 مشخص می‌شود.</p> <p>فرآیند پردازشی مربود به صفحه بندی به صورت بازگشتی است. این فرآیند از شی رندر ریشه که به تگ «html» اشاره می‌کند، شروع می‌شود و به صورت بازگشتی با پیمایش بعضی یا تمامی فریم‌های زیر مجموعه‌ای خود و محاسبه اطلاعات هندسی هر کدام از فریم‌ها که نیاز بود ادامه پیدا می‌کند. تمامی فریم‌ها دارای یک متد <code>layout</code> یا <code>reflow</code> هستند، که در صورت نیاز این وظیفه‌ی والد است که متد صفحه بندی فرزندانش را فراخوانی کند. در ویدیوی زیر به راحتی می‌توانید فرآیند صفحه بندی در مرورگر فایرفاکس را مشاهده کنید. (ویدیو بر روی سرویس یوتوب آپلود شده و برای دیدن آن نیاز به پراکسی دارید متاسفانه.)</p> <div class="video-wrapper text-center"><iframe width=560 height=420 data-layzr="https://www.youtube.com/embed/V6skIBKk0Js?color=white&amp;theme=light"></iframe></div> <h3 id=dirty-bit-system>سیستم کمی آلوده «dirty bit»</h3> <p>صفحه بندی فرآیند پر هزینه‌ است، خصوصا برای دستگاه‌های که از منابع پردازشی پایین‌تری بهره می‌برند؛ مانند گوشی‌های همراه. مرورگر برای اینکه برای هر تغییر کوچکی در صفحه مجبور نشود که کلا صفحه را دوباره صفحه بندی کند، از سیستم «کمی/مقداری/ذره‌ای-چرک/کثیف/آلوده» استفاده می‌کند. این سیستم هر فریمی که تغییر یا اضافه می‌شود به درخت رندر را، خودش و فرزندانش را به عنوان «آلوده» علامت گذاری می‌کند؛ که این یعنی، این ناحیه (فریم) نیاز به صفحه بندی مجدد دارد.</p> <p>در کل دو حالت در این سیستم وجود دارد: «<strong>آلوده</strong>» و «<strong>بچه‌های آلوده</strong>»؛ که این دومی به این معنی که ممکن است خود فریم تمیز باشد و نیازی به صفحه بندی مجدد نداشته باشه، ولی بچه‌هایش آلوده شده باشند و نیازمند صفحه‌بندی مجدد باشند.</p> <h3 id=global-and-incremental-layout>صفحه بندی: تدریجی و عمومی</h3> <p>صفحه بندی می‌تواند بر کل درخت رندر، اِعمال شود؛ که به این نوع می‌گوییم، صفحه بندی <strong>عمومی</strong> «global». صفحه بندی عمومی در صورتی که اتفاقات زیر رخ دهد بر روی درخت رندر اِعمال می‌شود:</p> <ol> <li>یکی از استایل‌های عمومی تغییر کند. مثلا اگه اندازه‌ی فونت تغییر کند، تمامی فریم‌ها تحت تاثیر قرار می‌گیرند.</li> <li>در صورتی که پنجره مرورگر تغییر سایز بدهد.</li> </ol> <p>نوع دیگر از صفحه بندی، صفحه بندی به صورت <strong>تدریجی</strong> «incremental»است؛ که وقتی که تغییرات رخ داده در حد یک ناحیه‌ی محلی باشد، که باعث تنها آلوده شدن یک فریم خاص از درخت رندر شده باشد بر روی درخت رندر اِعمال می‌شود. این نوع صفحه بندی به صورت موازی «asynchronously» بر فریم‌ها اعمال می‌شود. برای مثال وقتی که یک فریم جدید به درخت رندر اضافه می‌شود، فرآیند صفحه بندی صبر می‌کند تا اگر محتوای دیگری هم از لایه شبکه قرار است برسد به طور کامل بارگذاری و به درخت DOM‌ اضافه شود و بعد از آن فریم‌ جدید را صفحه بندی کند.</p> <figure class="lazy text-center"> <img src=/assets/images/placeholder.png data-layzr=/assets/images/content/2015/12/Incremental-layout.png alt=Incremental-layout> <figcaption>صفحه بندی تدریجی - تنها فریم‌های کثیف و فرزندانشان صفحه بندی می‌شوند.</figcaption> </figure> <h3 id=asynchronous-and-synchronous-layout>صفحه بندی: ترتیبی و موازی</h3> <p>همان طور که اشاره شد، صفحه بندی تدریجی به صورت موازی «asynchronously» اعمال می‌شود. فایرفاکس دستورات باز نشانی را برای اعمال صفحه بندی تدریجی صف بندی می‌کند و با تعیین یک زمان بندی به صورت دسته‌ای اقدام به اعمال این دستورات بر روی فریم‌ها می‌کند. در مقابل، وب‌کیت نیز دارای یک تایمر است که صفحه بندی تدریجی را اجرا می‌کند - به این صورت که درخت رندر را برای پیدا کردن فریم‌هایی که آلوده شده‌اند پیمایش می‌کند.</p> <p>وقتی که اسکریپتی در زمان اجرا، درخواست اطلاعات نظیر مقدار <code>offsetHeight</code> را از درخت استایل بکند، موجب این می‌شود که صفحه بندی دیگر نتواند به صورت موازی اعمال شود؛ و در این حالت باید به صورت ترتیبی انجام گیرد. صفحه بندی‌های عمومی هم معمولاً به صورت ترتیبی اعمال می‌شوند. نتایج این نوع تغییرات عمومی اصلاً خوش آیند مرورگر نیست. خصوصا در دستگاه‌‌های همراه که نیازمند آن هستند که محتوا را در فریم‌های ۶۰ ثانیه‌ای رندر و نمایش دهند. اگر عمر باقی بود سعی می‌کنم در آیند بیشتر در این بار بنویسم. اما فعلاً برای آشنایی بیشتر با <a href=http://taligarsiel.com/Projects/howbrowserswork1.htm#The_layout_process>فرآیند صفحه بندی</a> و <a href=http://taligarsiel.com/Projects/howbrowserswork1.htm#Width_calculation>نحوه محاسبات هندسی عناصر</a> می‌توانید به این پیوند‌ها مراجع کنید.</p> <h2 id=painting>رنگرزی «painting»</h2> <p>در این مرحله، درخت رندر، گره به گره پیمایش می‌شود و با فراخوانی متد <code>paint</code> هر شی رندر، باعث می‌شود تا محتوای این گره‌ها بر روی صفحه نمایش رسم و نقاشی شوند. لایه‌ی رنگرزی از کلاس‌های رابط کاربری سیستم عامل استفاده می‌کند.</p> <h3 id=global-and-incremental-painting>انواع فرآیندهای رنگرزی: عمومی و تدریجی</h3> <p>همانند لایه‌ی صفحه بندی، لایه‌ی رنگرزی هم می‌توانند به صورت عمومی - وقتی که کل درخت رندر نیازمند نقاشی باشد - و نیز تدریجی رخ دهد. رنگرزی تدریجی وقتی اعمال می‌شود که تغییر رخ داده تنها بر برخی از گره‌های درخت رندر تاثیر گذاشته باشد، نه بر کل درخت.</p> <p>با تغییر کردن یک فریم، ناحیه‌ی مستطیلی آن بر روی صفحه نمایش غیر معتبر می‌شود (شما همان حالت آلوده شدن در صفحه بندی را در نظر بگیرید) که این امر موجب آن می‌شود تا سیستم عامل با دیدن یک «منطقه‌ی آلوده» رخداد رنگرزی را فراخوانی کند. سیستم عامل این عمل را بسیار هوشمندانه انجام می‌دهد؛ به این ترتیب که سعی می‌کند تا آنجایی که امکان دارد این مناطق را در هم ادغام کند تا از بار پردازشی بکاهد. وقتی فریمی تغییر می‌کند، پیامی حاوی نشانی محدوده‌ی آلوده شده به ریشه درخت رندر فرستاده می‌شود و پیمایش درخت برای پیدا کردن گره‌ی آلوده شده شروع می‌شود؛ و تا زمانی که گره‌ی مورد نظر پیدا شود و متد <code>paint</code> آن (و در صورت نیاز فرزندانش نیز) برای رنگرزی دوباره فراخوانی شود.</p> <p>در مرورگر کروم این عملیات از این هم پیچیده‌تر است؛ چون فرآیند جداگانه‌ای از فرآیند اصلی برای این کار در نظر گرفته شده است. مدیریت این فرآیند به کل بر عهده‌ی پردازنده‌ی واحد گرافیکی «GPU» سیستم است؛ که مسول این چنین فرآیندهایی است. برای به کار گیری این پردازنده، کروم با کمی تغییرات تقریبا رفتار سیستم عامل را شبیه سازی کرده و در کنترل این پردازنده مانند آن عمل می‌کند. قبل از رنگرزی مجدد، وب‌کیت وضعیت ناحیه آلوده را قبل از آلوده شدن به صورت یک تصویر «bitmap» ذخیره می‌کند؛ و سپس با مقایسه تصاویر قبل و بعد از آلودگی، تنها نواحی را که آلوده شده اند؛ مجدد اقدام به رنگرزی می‌کند.</p> <h3 id=the-painting-order>ترتیب اولویت‌های رنگرزی</h3> <p><a href=http://www.w3.org/TR/CSS21/zindex.html>در مستندات CSS2 فرآیند رنگرزی الویت بندی شده است</a> . به موجب این اولویت بندی، فرآیند رنگرزی از عقب ترین بلوک آغاز می‌شود تا به جلویی ترین بلوک برسد (جلویی ترین بلوک، نزدیک‌ترین بلوک به کاربر است در صفحه نمایش؛ که از همان سیستم «z-index» پیروی می‌کند). اولویت بندی بلوک‌های هر فریم به صورت زیر است:</p> <ol> <li>رنگ پس زمینه</li> <li>تصویر پس زمینه</li> <li>حاشیه «border»</li> <li>فرزندان</li> <li>نوار بیرونی «outline»</li> </ol> <h3 id=dynamic-changes>انعطاف در برابر تغییرات</h3> <p>مرورگرها سعی می‌کنند تا آنجایی که امکان پذیر است با انجام کمترین کار نسبت به تغییرات محتوا و رفتارهای کاربر واکنش نشان دهند؛ به همین دلیل، همه تغییرات دارای هزینه‌ی یکسانی برای مرورگر نیستند. برای مثال تغییر رنگ یک عنصر، تنها باعث انجام عملیات رنگرزی مجدد بر روی خود آن عنصر می‌شود. یا تغییرات موقعیت یک عنصر باعث این می‌شود که مرورگر مجبور شود عملیات‌های صفحه بندی و رنگرزی را برای خود آن عنصر، فرزندانش و همسایگانش نیز انجام دهد. وقوع تغییرات بنیادی مانند تغییر سایز فونت تگ «html»، موجب نامعتبر شدن کش‌های ایجاد شده توسط موتور رندر شده و موتور مجبور می‌شود تا کل درخت رندر را دوباره از نو صفحه بندی و رنگرزی کند.</p> <p>این وظیفه‌ی توسعه دهندگان است که مراقب باشند تا مرورگر چه از سوی کد آن‌ها به طور مستقیم و چه به واسطه‌ی رفتار کاربران به طور غیر مستقیم دچار چنین زحماتی نشود و تا جایی که امکان دارد از رفتارهایی که باعث تغییرات بنیادی می‌شود، اجتناب کند. من سعی خواهم کرد تا در مطالب آتی در این باره به طور مفصل صحبت کنم. زیرا این مبحث یکی از اصلی‌ترین عوامل تاثیرگذار بر کارایی وب سایت‌های واکنش‌گرا در مرورگرهای موبایل است؛ ولی تا آن زمان می‌توانید نقداً با مراجعه به سایت <a href="http://csstriggers.com/">csstriggers.com</a> از هزینه‌ی تغییر هر یک از خصوصیات استایلی عناصر صفحه آگاه شوید.</p> <h3 id=the-rendering-engine-threads>جریان‌های موتور رندر کننده</h3> <p>موتور رندر تنها دارای یک جریان «thread» است. تقریبا همه فرآیندها در مرورگرها به جز عملیات‌های شبکه‌ای، توسط همین جریان پردازش می‌شوند. در فایرفاکس و سافاری، این جریان، جریان اصلی پردازشی مرورگر است. در کروم نیز همان طور که پیش از این عنوان شد، هر تب، یک جریان اصلی مخصوص به خودش را دارد.</p> <p>تنها لایه‌ی شبکه است که مجاز است به طور موازی و همزمان عملیات‌های خودش را در قالب جریان‌های جداگانه از هم انجام دهد. البته مرورگر تعداد کانکشن‌های که به این صورت می‌تواند برقرار کند، محدود است (معمولا بین ۲ الی ۶ کانکشن متغییر است).</p> <h4 id=event-loop>حلقه‌ی رخداد</h4> <p>از طرفی، جریان اصلی مرورگرها یک حلقه‌ی بی‌نهایت از نوع رخدادها «event» است. وظیفه‌ی اصلی این حلقه بی‌نهایت، هوشیار نگاه داشتن جریان اصلی نسبت به تغییرات احتمالی (مانند رخدادهای که موجب صفحه بندی و رنگرزی مجدد می‌شوند) و واکنش نشان دادن نسبت به آنها است. کد زیر نشان دهنده‌ی حلقه‌ی رخداد اصلی در مرورگر فایرفاکس است:</p> <div class="code-wrapper mb-base"> <div class=container> <pre><code class=language-javascript>while (!mExiting)
  NS_ProcessNextEvent(thread);</code></pre> </div> </div> <h2 id=last-words>سخن پایانی</h2> <p>مایه‌ی اصلی این متن، بر اساس تحقیقات توسعه دهنده‌ی اسرائیلی‌، خانوم «Tali Garsiel»، که در <a href=http://taligarsiel.com/Projects/howbrowserswork1.htm>سایت</a> خود منتشر کرده‌اند زده شده است. در بعضی از قسمت‌ها که به نظرم رسیده نیاز به عمیق شدن به آن شدتی که ایشان شده اند، نبوده؛ من راه خودم را از ایشان جدا کرده ام و سعی کردم، یا یک شرح مختصر از کلیات آن قسمت داشته باشم؛ یا به کل آن‌ها را نادیده بگیرم. در انتهای این بخش‌ها به همان قسمت از مقاله‌ی اصلی ارجاع داده‌ام تا دوستان علاقمند بتوانند راحت‌تر به عمق‌های بعدی نفوذ کنند. در مواردی هم که احساس کرده‌ام نیاز به توضیح بیشتر بوده، سعی کرده‌ام تا آن جایی که سوادم اجازه می‌داده مطلب را بیشتر بشکافم. در هر صورت امیدوارم از خواندن این ترجمه-تالیف لذت برده باشید.</p> <p>به پایان آمد این دفتر، حکایت هم چنان باقی است… .</p> </div> </div> </article> <div class="post-meta container mb-base"> <div class=post-tags> <a class=post-tag href="/blog/tag/learning/">آموزشی</a> <a class=post-tag href="/blog/tag/reference/">مطالب مرجع</a> <a class=post-tag href="/blog/tag/frontend/">Front-End</a> <a class=post-tag href="/blog/tag/browsers/">مرورگرها</a> <a class=post-tag href="/blog/tag/html/">HTML</a> <a class=post-tag href="/blog/tag/css/">CSS</a> <a class=post-tag href="/blog/tag/webkit/">WebKit</a> <a class=post-tag href="/blog/tag/firefox/">فایرفاکس</a> <a class=post-tag href="/blog/tag/chrome/">کروم</a> </div> </div> <div class="share-links mb-double container"> <h4>به اشتراک بگذارید: </h4> <ul class="list clearfix"> <li class="share-links__item mb-base"><a href="https://twitter.com/intent/tweet?text=مرورگرها چگونه کار می‌کنند؟&url=https://naser.dev/blog/2015/how-browsers-work/&via=snhasani" target=_blank rel=nofollow title="اشتراک گذاری در تویتتر">توییتر</a></li> <li class="share-links__item mb-base"><a href="https://facebook.com/sharer.php?u=https://naser.dev/blog/2015/how-browsers-work/" rel=nofollow target=_blank title="اشتراک گذاری در فیسبوک">فیس‌بوک</a></li> <li class="share-links__item mb-base"><a href="https://plus.google.com/share?url=https://naser.dev/blog/2015/how-browsers-work/" rel=nofollow target=_blank title="اشتراک گذاری در گوگل پلاس">گوگل پلاس</a></li> <li class="share-links__item mb-base"><a href="https://www.linkedin.com/shareArticle?mini=true&url=https://naser.dev&title=مرورگرها چگونه کار می‌کنند؟&source=https://naser.dev&summary=مرورگرهای وب جزء پر استفاده ترین نرم افزارهای هستند، که تا به حال به دست بشر ساخته شده‌اند. به همین منظور، سفر اکتشافی خواهیم داشته، به اعماق این موجودات؛ تا..." title="اشتراک گذاری در لینکدین" target=_blank>لینکدین</a></li> </ul> </div> <div class="post-nav-links container mb-double clearfix"> <div class="previous mb-base"><strong>مطلب قبلی</strong><a href="/blog/2015/hello-world/">دوباره، سلام دنیا! <span class=pagination__icon>◀</span></a></div> <div class=next><strong>مطلب بعدی</strong><a href="/blog/2015/nvm/"><span class=pagination__icon>▶</span> چگونه نسخه‌های مختلف nodejs‌ را رام کنیم؟</a></div> </div> <div class="text-center mb-double"><a href=#top class=go-top>بازگشت به بالای صفحه</a></div> <p class="container mb-double">اگر نشانگر بارگزاری زیر چرخید و هیچ اتفاقی نیفتاد و کامنت‌ها لود نشد، با عرض پوزش باید عرض کنم که متاسفانه شما بدون پراکسی اینجا هستید و از اونجایی که فیلترچی سرویس مورد نظر را مسدود کرده است، تا وقتی که با پراکسی صفحه را مجدداْ لود نفرمایید نمی‌توانید کامنت‌ها را مشاهده کنید :((</p> <div class="container mb-double"> <div id=disqus_thread></div> </div> <script id=disqus>var disqus_config=function(){this.page.url='https://naser.dev/blog/2015/how-browsers-work/';this.page.identifier='/blog/2015/how-browsers-work/'};(function(w){w.addEventListener("load",function(){var d=document,s=d.createElement('script');s.async=true;s.src ='//naserxyz.disqus.com/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})})(window)</script> </div> <footer class="site-footer container text-center clearfix" role=contentinfo dir=ltr> <nav class="nav social-links"> <ul class=list> <li class=nav__item><a href=https://github.com/snhasani target=blank>Github</a></li>  <li class=nav__item><a href=/rss.xml target=blank>RSS</a></li> </ul> </nav> <p class=copyright>&copy;&nbsp;2023 Naser.</p> <div class=theme-switch> <div class=theme-switch__button></div> </div> </footer> </div> <script id=loadJS__onload>!function(a){"use strict";a.loadOnloadJS=function(b,c,d){a.addEventListener("load",function(){loadJS(b,c,d)},!1)},a.loadJS=function(b,c,d){var s=a.document.createElement("script");s.src=b,s.async=c||!1,a.document.body.appendChild(s);if(d&& typeof(d)==='function'){s.onload=d}return s}}(window);loadOnloadJS( '/assets/scripts/main.js', true);</script> <script id=loadJS__prism>
				(function(){var s=document.querySelector('code[class*="language-"]');if(s){loadOnloadJS('/assets/scripts/prism.js', true, function(){Prism.highlightAll()})}})()
			</script> <script>
			(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
			function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
			e=o.createElement(i);r=o.getElementsByTagName(i)[0];
			e.async = true;
			e.src='https://www.google-analytics.com/analytics.js';
			r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
			ga('create','UA-45098305-5','auto');ga('send','pageview');
		</script> </body> </html> 